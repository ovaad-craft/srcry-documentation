(() => { "use strict"; var e, v = {}, _ = {}; function a(e) { var f = _[e]; if (void 0 !== f) return f.exports; var r = _[e] = { exports: {} }; return v[e](r, r.exports, a), r.exports } a.m = v, e = [], a.O = (f, r, t, o) => { if (!r) { var u = 1 / 0; for (n = 0; n < e.length; n++) { for (var [r, t, o] = e[n], s = !0, l = 0; l < r.length; l++)(!1 & o || u >= o) && Object.keys(a.O).every(h => a.O[h](r[l])) ? r.splice(l--, 1) : (s = !1, o < u && (u = o)); if (s) { e.splice(n--, 1); var c = t(); void 0 !== c && (f = c) } } return f } o = o || 0; for (var n = e.length; n > 0 && e[n - 1][2] > o; n--)e[n] = e[n - 1]; e[n] = [r, t, o] }, a.o = (e, f) => Object.prototype.hasOwnProperty.call(e, f), (() => { var e = { 666: 0 }; a.O.j = t => 0 === e[t]; var f = (t, o) => { var l, c, [n, u, s] = o, i = 0; if (n.some(d => 0 !== e[d])) { for (l in u) a.o(u, l) && (a.m[l] = u[l]); if (s) var p = s(a) } for (t && t(o); i < n.length; i++)a.o(e, c = n[i]) && e[c] && e[c][0](), e[c] = 0; return a.O(p) }, r = self.webpackChunktinker_component = self.webpackChunktinker_component || []; r.forEach(f.bind(null, 0)), r.push = f.bind(null, r.push.bind(r)) })() })(); "use strict"; (self.webpackChunktinker_component = self.webpackChunktinker_component || []).push([[429], { 332: () => { !function (e) { const n = e.performance; function s(j) { n && n.mark && n.mark(j) } function r(j, h) { n && n.measure && n.measure(j, h) } s("Zone"); const i = e.__Zone_symbol_prefix || "__zone_symbol__"; function l(j) { return i + j } const p = !0 === e[l("forceDuplicateZoneCheck")]; if (e.Zone) { if (p || "function" != typeof e.Zone.__symbol__) throw new Error("Zone already loaded."); return e.Zone } let E = (() => { class h { static assertZonePatched() { if (e.Promise !== oe.ZoneAwarePromise) throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)") } static get root() { let t = h.current; for (; t.parent;)t = t.parent; return t } static get current() { return W.zone } static get currentTask() { return re } static __load_patch(t, _, w = !1) { if (oe.hasOwnProperty(t)) { if (!w && p) throw Error("Already loaded patch: " + t) } else if (!e["__Zone_disable_" + t]) { const L = "Zone:" + t; s(L), oe[t] = _(e, h, Y), r(L, L) } } get parent() { return this._parent } get name() { return this._name } constructor(t, _) { this._parent = t, this._name = _ ? _.name || "unnamed" : "<root>", this._properties = _ && _.properties || {}, this._zoneDelegate = new v(this, this._parent && this._parent._zoneDelegate, _) } get(t) { const _ = this.getZoneWith(t); if (_) return _._properties[t] } getZoneWith(t) { let _ = this; for (; _;) { if (_._properties.hasOwnProperty(t)) return _; _ = _._parent } return null } fork(t) { if (!t) throw new Error("ZoneSpec required!"); return this._zoneDelegate.fork(this, t) } wrap(t, _) { if ("function" != typeof t) throw new Error("Expecting function got: " + t); const w = this._zoneDelegate.intercept(this, t, _), L = this; return function () { return L.runGuarded(w, this, arguments, _) } } run(t, _, w, L) { W = { parent: W, zone: this }; try { return this._zoneDelegate.invoke(this, t, _, w, L) } finally { W = W.parent } } runGuarded(t, _ = null, w, L) { W = { parent: W, zone: this }; try { try { return this._zoneDelegate.invoke(this, t, _, w, L) } catch (a) { if (this._zoneDelegate.handleError(this, a)) throw a } } finally { W = W.parent } } runTask(t, _, w) { if (t.zone != this) throw new Error("A task can only be run in the zone of creation! (Creation: " + (t.zone || J).name + "; Execution: " + this.name + ")"); if (t.state === G && (t.type === Q || t.type === P)) return; const L = t.state != y; L && t._transitionTo(y, A), t.runCount++; const a = re; re = t, W = { parent: W, zone: this }; try { t.type == P && t.data && !t.data.isPeriodic && (t.cancelFn = void 0); try { return this._zoneDelegate.invokeTask(this, t, _, w) } catch (u) { if (this._zoneDelegate.handleError(this, u)) throw u } } finally { t.state !== G && t.state !== d && (t.type == Q || t.data && t.data.isPeriodic ? L && t._transitionTo(A, y) : (t.runCount = 0, this._updateTaskCount(t, -1), L && t._transitionTo(G, y, G))), W = W.parent, re = a } } scheduleTask(t) { if (t.zone && t.zone !== this) { let w = this; for (; w;) { if (w === t.zone) throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${t.zone.name}`); w = w.parent } } t._transitionTo(z, G); const _ = []; t._zoneDelegates = _, t._zone = this; try { t = this._zoneDelegate.scheduleTask(this, t) } catch (w) { throw t._transitionTo(d, z, G), this._zoneDelegate.handleError(this, w), w } return t._zoneDelegates === _ && this._updateTaskCount(t, 1), t.state == z && t._transitionTo(A, z), t } scheduleMicroTask(t, _, w, L) { return this.scheduleTask(new m(I, t, _, w, L, void 0)) } scheduleMacroTask(t, _, w, L, a) { return this.scheduleTask(new m(P, t, _, w, L, a)) } scheduleEventTask(t, _, w, L, a) { return this.scheduleTask(new m(Q, t, _, w, L, a)) } cancelTask(t) { if (t.zone != this) throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (t.zone || J).name + "; Execution: " + this.name + ")"); if (t.state === A || t.state === y) { t._transitionTo(V, A, y); try { this._zoneDelegate.cancelTask(this, t) } catch (_) { throw t._transitionTo(d, V), this._zoneDelegate.handleError(this, _), _ } return this._updateTaskCount(t, -1), t._transitionTo(G, V), t.runCount = 0, t } } _updateTaskCount(t, _) { const w = t._zoneDelegates; -1 == _ && (t._zoneDelegates = null); for (let L = 0; L < w.length; L++)w[L]._updateTaskCount(t.type, _) } } return h.__symbol__ = l, h })(); const b = { name: "", onHasTask: (j, h, c, t) => j.hasTask(c, t), onScheduleTask: (j, h, c, t) => j.scheduleTask(c, t), onInvokeTask: (j, h, c, t, _, w) => j.invokeTask(c, t, _, w), onCancelTask: (j, h, c, t) => j.cancelTask(c, t) }; class v { constructor(h, c, t) { this._taskCounts = { microTask: 0, macroTask: 0, eventTask: 0 }, this.zone = h, this._parentDelegate = c, this._forkZS = t && (t && t.onFork ? t : c._forkZS), this._forkDlgt = t && (t.onFork ? c : c._forkDlgt), this._forkCurrZone = t && (t.onFork ? this.zone : c._forkCurrZone), this._interceptZS = t && (t.onIntercept ? t : c._interceptZS), this._interceptDlgt = t && (t.onIntercept ? c : c._interceptDlgt), this._interceptCurrZone = t && (t.onIntercept ? this.zone : c._interceptCurrZone), this._invokeZS = t && (t.onInvoke ? t : c._invokeZS), this._invokeDlgt = t && (t.onInvoke ? c : c._invokeDlgt), this._invokeCurrZone = t && (t.onInvoke ? this.zone : c._invokeCurrZone), this._handleErrorZS = t && (t.onHandleError ? t : c._handleErrorZS), this._handleErrorDlgt = t && (t.onHandleError ? c : c._handleErrorDlgt), this._handleErrorCurrZone = t && (t.onHandleError ? this.zone : c._handleErrorCurrZone), this._scheduleTaskZS = t && (t.onScheduleTask ? t : c._scheduleTaskZS), this._scheduleTaskDlgt = t && (t.onScheduleTask ? c : c._scheduleTaskDlgt), this._scheduleTaskCurrZone = t && (t.onScheduleTask ? this.zone : c._scheduleTaskCurrZone), this._invokeTaskZS = t && (t.onInvokeTask ? t : c._invokeTaskZS), this._invokeTaskDlgt = t && (t.onInvokeTask ? c : c._invokeTaskDlgt), this._invokeTaskCurrZone = t && (t.onInvokeTask ? this.zone : c._invokeTaskCurrZone), this._cancelTaskZS = t && (t.onCancelTask ? t : c._cancelTaskZS), this._cancelTaskDlgt = t && (t.onCancelTask ? c : c._cancelTaskDlgt), this._cancelTaskCurrZone = t && (t.onCancelTask ? this.zone : c._cancelTaskCurrZone), this._hasTaskZS = null, this._hasTaskDlgt = null, this._hasTaskDlgtOwner = null, this._hasTaskCurrZone = null; const _ = t && t.onHasTask; (_ || c && c._hasTaskZS) && (this._hasTaskZS = _ ? t : b, this._hasTaskDlgt = c, this._hasTaskDlgtOwner = this, this._hasTaskCurrZone = h, t.onScheduleTask || (this._scheduleTaskZS = b, this._scheduleTaskDlgt = c, this._scheduleTaskCurrZone = this.zone), t.onInvokeTask || (this._invokeTaskZS = b, this._invokeTaskDlgt = c, this._invokeTaskCurrZone = this.zone), t.onCancelTask || (this._cancelTaskZS = b, this._cancelTaskDlgt = c, this._cancelTaskCurrZone = this.zone)) } fork(h, c) { return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, h, c) : new E(h, c) } intercept(h, c, t) { return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, h, c, t) : c } invoke(h, c, t, _, w) { return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, h, c, t, _, w) : c.apply(t, _) } handleError(h, c) { return !this._handleErrorZS || this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, h, c) } scheduleTask(h, c) { let t = c; if (this._scheduleTaskZS) this._hasTaskZS && t._zoneDelegates.push(this._hasTaskDlgtOwner), t = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, h, c), t || (t = c); else if (c.scheduleFn) c.scheduleFn(c); else { if (c.type != I) throw new Error("Task is missing scheduleFn."); C(c) } return t } invokeTask(h, c, t, _) { return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, h, c, t, _) : c.callback.apply(t, _) } cancelTask(h, c) { let t; if (this._cancelTaskZS) t = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, h, c); else { if (!c.cancelFn) throw Error("Task is not cancelable"); t = c.cancelFn(c) } return t } hasTask(h, c) { try { this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, h, c) } catch (t) { this.handleError(h, t) } } _updateTaskCount(h, c) { const t = this._taskCounts, _ = t[h], w = t[h] = _ + c; if (w < 0) throw new Error("More tasks executed then were scheduled."); 0 != _ && 0 != w || this.hasTask(this.zone, { microTask: t.microTask > 0, macroTask: t.macroTask > 0, eventTask: t.eventTask > 0, change: h }) } } class m { constructor(h, c, t, _, w, L) { if (this._zone = null, this.runCount = 0, this._zoneDelegates = null, this._state = "notScheduled", this.type = h, this.source = c, this.data = _, this.scheduleFn = w, this.cancelFn = L, !t) throw new Error("callback is not defined"); this.callback = t; const a = this; this.invoke = h === Q && _ && _.useG ? m.invokeTask : function () { return m.invokeTask.call(e, a, this, arguments) } } static invokeTask(h, c, t) { h || (h = this), ee++; try { return h.runCount++, h.zone.runTask(h, c, t) } finally { 1 == ee && T(), ee-- } } get zone() { return this._zone } get state() { return this._state } cancelScheduleRequest() { this._transitionTo(G, z) } _transitionTo(h, c, t) { if (this._state !== c && this._state !== t) throw new Error(`${this.type} '${this.source}': can not transition to '${h}', expecting state '${c}'${t ? " or '" + t + "'" : ""}, was '${this._state}'.`); this._state = h, h == G && (this._zoneDelegates = null) } toString() { return this.data && typeof this.data.handleId < "u" ? this.data.handleId.toString() : Object.prototype.toString.call(this) } toJSON() { return { type: this.type, state: this.state, source: this.source, zone: this.zone.name, runCount: this.runCount } } } const M = l("setTimeout"), O = l("Promise"), N = l("then"); let K, U = [], x = !1; function X(j) { if (K || e[O] && (K = e[O].resolve(0)), K) { let h = K[N]; h || (h = K.then), h.call(K, j) } else e[M](j, 0) } function C(j) { 0 === ee && 0 === U.length && X(T), j && U.push(j) } function T() { if (!x) { for (x = !0; U.length;) { const j = U; U = []; for (let h = 0; h < j.length; h++) { const c = j[h]; try { c.zone.runTask(c, null, null) } catch (t) { Y.onUnhandledError(t) } } } Y.microtaskDrainDone(), x = !1 } } const J = { name: "NO ZONE" }, G = "notScheduled", z = "scheduling", A = "scheduled", y = "running", V = "canceling", d = "unknown", I = "microTask", P = "macroTask", Q = "eventTask", oe = {}, Y = { symbol: l, currentZoneFrame: () => W, onUnhandledError: q, microtaskDrainDone: q, scheduleMicroTask: C, showUncaughtError: () => !E[l("ignoreConsoleErrorUncaughtError")], patchEventTarget: () => [], patchOnProperties: q, patchMethod: () => q, bindArguments: () => [], patchThen: () => q, patchMacroTask: () => q, patchEventPrototype: () => q, isIEOrEdge: () => !1, getGlobalObjects: () => { }, ObjectDefineProperty: () => q, ObjectGetOwnPropertyDescriptor: () => { }, ObjectCreate: () => { }, ArraySlice: () => [], patchClass: () => q, wrapWithCurrentZone: () => q, filterProperties: () => [], attachOriginToPatched: () => q, _redefineProperty: () => q, patchCallbacks: () => q, nativeScheduleMicroTask: X }; let W = { parent: null, zone: new E(null, null) }, re = null, ee = 0; function q() { } r("Zone", "Zone"), e.Zone = E }(typeof window < "u" && window || typeof self < "u" && self || global); const ue = Object.getOwnPropertyDescriptor, pe = Object.defineProperty, ve = Object.getPrototypeOf, Se = Object.create, it = Array.prototype.slice, Ze = "addEventListener", De = "removeEventListener", Oe = Zone.__symbol__(Ze), Ne = Zone.__symbol__(De), ie = "true", ce = "false", me = Zone.__symbol__(""); function Ie(e, n) { return Zone.current.wrap(e, n) } function Me(e, n, s, r, i) { return Zone.current.scheduleMacroTask(e, n, s, r, i) } const H = Zone.__symbol__, be = typeof window < "u", _e = be ? window : void 0, $ = be && _e || "object" == typeof self && self || global, ct = "removeAttribute"; function Le(e, n) { for (let s = e.length - 1; s >= 0; s--)"function" == typeof e[s] && (e[s] = Ie(e[s], n + "_" + s)); return e } function Ve(e) { return !e || !1 !== e.writable && !("function" == typeof e.get && typeof e.set > "u") } const Fe = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, Pe = !("nw" in $) && typeof $.process < "u" && "[object process]" === {}.toString.call($.process), Ae = !Pe && !Fe && !(!be || !_e.HTMLElement), Be = typeof $.process < "u" && "[object process]" === {}.toString.call($.process) && !Fe && !(!be || !_e.HTMLElement), we = {}, Ue = function (e) { if (!(e = e || $.event)) return; let n = we[e.type]; n || (n = we[e.type] = H("ON_PROPERTY" + e.type)); const s = this || e.target || $, r = s[n]; let i; return Ae && s === _e && "error" === e.type ? (i = r && r.call(this, e.message, e.filename, e.lineno, e.colno, e.error), !0 === i && e.preventDefault()) : (i = r && r.apply(this, arguments), null != i && !i && e.preventDefault()), i }; function We(e, n, s) { let r = ue(e, n); if (!r && s && ue(s, n) && (r = { enumerable: !0, configurable: !0 }), !r || !r.configurable) return; const i = H("on" + n + "patched"); if (e.hasOwnProperty(i) && e[i]) return; delete r.writable, delete r.value; const l = r.get, p = r.set, E = n.slice(2); let b = we[E]; b || (b = we[E] = H("ON_PROPERTY" + E)), r.set = function (v) { let m = this; !m && e === $ && (m = $), m && ("function" == typeof m[b] && m.removeEventListener(E, Ue), p && p.call(m, null), m[b] = v, "function" == typeof v && m.addEventListener(E, Ue, !1)) }, r.get = function () { let v = this; if (!v && e === $ && (v = $), !v) return null; const m = v[b]; if (m) return m; if (l) { let M = l.call(this); if (M) return r.set.call(this, M), "function" == typeof v[ct] && v.removeAttribute(n), M } return null }, pe(e, n, r), e[i] = !0 } function qe(e, n, s) { if (n) for (let r = 0; r < n.length; r++)We(e, "on" + n[r], s); else { const r = []; for (const i in e) "on" == i.slice(0, 2) && r.push(i); for (let i = 0; i < r.length; i++)We(e, r[i], s) } } const ne = H("originalInstance"); function ge(e) { const n = $[e]; if (!n) return; $[H(e)] = n, $[e] = function () { const i = Le(arguments, e); switch (i.length) { case 0: this[ne] = new n; break; case 1: this[ne] = new n(i[0]); break; case 2: this[ne] = new n(i[0], i[1]); break; case 3: this[ne] = new n(i[0], i[1], i[2]); break; case 4: this[ne] = new n(i[0], i[1], i[2], i[3]); break; default: throw new Error("Arg list too long.") } }, le($[e], n); const s = new n(function () { }); let r; for (r in s) "XMLHttpRequest" === e && "responseBlob" === r || function (i) { "function" == typeof s[i] ? $[e].prototype[i] = function () { return this[ne][i].apply(this[ne], arguments) } : pe($[e].prototype, i, { set: function (l) { "function" == typeof l ? (this[ne][i] = Ie(l, e + "." + i), le(this[ne][i], l)) : this[ne][i] = l }, get: function () { return this[ne][i] } }) }(r); for (r in n) "prototype" !== r && n.hasOwnProperty(r) && ($[e][r] = n[r]) } function ae(e, n, s) { let r = e; for (; r && !r.hasOwnProperty(n);)r = ve(r); !r && e[n] && (r = e); const i = H(n); let l = null; if (r && (!(l = r[i]) || !r.hasOwnProperty(i)) && (l = r[i] = r[n], Ve(r && ue(r, n)))) { const E = s(l, i, n); r[n] = function () { return E(this, arguments) }, le(r[n], l) } return l } function lt(e, n, s) { let r = null; function i(l) { const p = l.data; return p.args[p.cbIdx] = function () { l.invoke.apply(this, arguments) }, r.apply(p.target, p.args), l } r = ae(e, n, l => function (p, E) { const b = s(p, E); return b.cbIdx >= 0 && "function" == typeof E[b.cbIdx] ? Me(b.name, E[b.cbIdx], b, i) : l.apply(p, E) }) } function le(e, n) { e[H("OriginalDelegate")] = n } let Xe = !1, je = !1; function ft() { if (Xe) return je; Xe = !0; try { const e = _e.navigator.userAgent; (-1 !== e.indexOf("MSIE ") || -1 !== e.indexOf("Trident/") || -1 !== e.indexOf("Edge/")) && (je = !0) } catch { } return je } Zone.__load_patch("ZoneAwarePromise", (e, n, s) => { const r = Object.getOwnPropertyDescriptor, i = Object.defineProperty, p = s.symbol, E = [], b = !0 === e[p("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")], v = p("Promise"), m = p("then"), M = "__creationTrace__"; s.onUnhandledError = a => { if (s.showUncaughtError()) { const u = a && a.rejection; u ? console.error("Unhandled Promise rejection:", u instanceof Error ? u.message : u, "; Zone:", a.zone.name, "; Task:", a.task && a.task.source, "; Value:", u, u instanceof Error ? u.stack : void 0) : console.error(a) } }, s.microtaskDrainDone = () => { for (; E.length;) { const a = E.shift(); try { a.zone.runGuarded(() => { throw a.throwOriginal ? a.rejection : a }) } catch (u) { N(u) } } }; const O = p("unhandledPromiseRejectionHandler"); function N(a) { s.onUnhandledError(a); try { const u = n[O]; "function" == typeof u && u.call(this, a) } catch { } } function U(a) { return a && a.then } function x(a) { return a } function K(a) { return c.reject(a) } const X = p("state"), C = p("value"), T = p("finally"), J = p("parentPromiseValue"), G = p("parentPromiseState"), z = "Promise.then", A = null, y = !0, V = !1, d = 0; function I(a, u) { return o => { try { Y(a, u, o) } catch (f) { Y(a, !1, f) } } } const P = function () { let a = !1; return function (o) { return function () { a || (a = !0, o.apply(null, arguments)) } } }, Q = "Promise resolved with itself", oe = p("currentTaskTrace"); function Y(a, u, o) { const f = P(); if (a === o) throw new TypeError(Q); if (a[X] === A) { let k = null; try { ("object" == typeof o || "function" == typeof o) && (k = o && o.then) } catch (R) { return f(() => { Y(a, !1, R) })(), a } if (u !== V && o instanceof c && o.hasOwnProperty(X) && o.hasOwnProperty(C) && o[X] !== A) re(o), Y(a, o[X], o[C]); else if (u !== V && "function" == typeof k) try { k.call(o, f(I(a, u)), f(I(a, !1))) } catch (R) { f(() => { Y(a, !1, R) })() } else { a[X] = u; const R = a[C]; if (a[C] = o, a[T] === T && u === y && (a[X] = a[G], a[C] = a[J]), u === V && o instanceof Error) { const g = n.currentTask && n.currentTask.data && n.currentTask.data[M]; g && i(o, oe, { configurable: !0, enumerable: !1, writable: !0, value: g }) } for (let g = 0; g < R.length;)ee(a, R[g++], R[g++], R[g++], R[g++]); if (0 == R.length && u == V) { a[X] = d; let g = o; try { throw new Error("Uncaught (in promise): " + function l(a) { return a && a.toString === Object.prototype.toString ? (a.constructor && a.constructor.name || "") + ": " + JSON.stringify(a) : a ? a.toString() : Object.prototype.toString.call(a) }(o) + (o && o.stack ? "\n" + o.stack : "")) } catch (S) { g = S } b && (g.throwOriginal = !0), g.rejection = o, g.promise = a, g.zone = n.current, g.task = n.currentTask, E.push(g), s.scheduleMicroTask() } } } return a } const W = p("rejectionHandledHandler"); function re(a) { if (a[X] === d) { try { const u = n[W]; u && "function" == typeof u && u.call(this, { rejection: a[C], promise: a }) } catch { } a[X] = V; for (let u = 0; u < E.length; u++)a === E[u].promise && E.splice(u, 1) } } function ee(a, u, o, f, k) { re(a); const R = a[X], g = R ? "function" == typeof f ? f : x : "function" == typeof k ? k : K; u.scheduleMicroTask(z, () => { try { const S = a[C], Z = !!o && T === o[T]; Z && (o[J] = S, o[G] = R); const D = u.run(g, void 0, Z && g !== K && g !== x ? [] : [S]); Y(o, !0, D) } catch (S) { Y(o, !1, S) } }, o) } const j = function () { }, h = e.AggregateError; class c { static toString() { return "function ZoneAwarePromise() { [native code] }" } static resolve(u) { return Y(new this(null), y, u) } static reject(u) { return Y(new this(null), V, u) } static any(u) { if (!u || "function" != typeof u[Symbol.iterator]) return Promise.reject(new h([], "All promises were rejected")); const o = []; let f = 0; try { for (let g of u) f++, o.push(c.resolve(g)) } catch { return Promise.reject(new h([], "All promises were rejected")) } if (0 === f) return Promise.reject(new h([], "All promises were rejected")); let k = !1; const R = []; return new c((g, S) => { for (let Z = 0; Z < o.length; Z++)o[Z].then(D => { k || (k = !0, g(D)) }, D => { R.push(D), f--, 0 === f && (k = !0, S(new h(R, "All promises were rejected"))) }) }) } static race(u) { let o, f, k = new this((S, Z) => { o = S, f = Z }); function R(S) { o(S) } function g(S) { f(S) } for (let S of u) U(S) || (S = this.resolve(S)), S.then(R, g); return k } static all(u) { return c.allWithCallback(u) } static allSettled(u) { return (this && this.prototype instanceof c ? this : c).allWithCallback(u, { thenCallback: f => ({ status: "fulfilled", value: f }), errorCallback: f => ({ status: "rejected", reason: f }) }) } static allWithCallback(u, o) { let f, k, R = new this((D, F) => { f = D, k = F }), g = 2, S = 0; const Z = []; for (let D of u) { U(D) || (D = this.resolve(D)); const F = S; try { D.then(B => { Z[F] = o ? o.thenCallback(B) : B, g--, 0 === g && f(Z) }, B => { o ? (Z[F] = o.errorCallback(B), g--, 0 === g && f(Z)) : k(B) }) } catch (B) { k(B) } g++, S++ } return g -= 2, 0 === g && f(Z), R } constructor(u) { const o = this; if (!(o instanceof c)) throw new Error("Must be an instanceof Promise."); o[X] = A, o[C] = []; try { const f = P(); u && u(f(I(o, y)), f(I(o, V))) } catch (f) { Y(o, !1, f) } } get [Symbol.toStringTag]() { return "Promise" } get [Symbol.species]() { return c } then(u, o) { let f = this.constructor?.[Symbol.species]; (!f || "function" != typeof f) && (f = this.constructor || c); const k = new f(j), R = n.current; return this[X] == A ? this[C].push(R, k, u, o) : ee(this, R, k, u, o), k } catch(u) { return this.then(null, u) } finally(u) { let o = this.constructor?.[Symbol.species]; (!o || "function" != typeof o) && (o = c); const f = new o(j); f[T] = T; const k = n.current; return this[X] == A ? this[C].push(k, f, u, u) : ee(this, k, f, u, u), f } } c.resolve = c.resolve, c.reject = c.reject, c.race = c.race, c.all = c.all; const t = e[v] = e.Promise; e.Promise = c; const _ = p("thenPatched"); function w(a) { const u = a.prototype, o = r(u, "then"); if (o && (!1 === o.writable || !o.configurable)) return; const f = u.then; u[m] = f, a.prototype.then = function (k, R) { return new c((S, Z) => { f.call(this, S, Z) }).then(k, R) }, a[_] = !0 } return s.patchThen = w, t && (w(t), ae(e, "fetch", a => function L(a) { return function (u, o) { let f = a.apply(u, o); if (f instanceof c) return f; let k = f.constructor; return k[_] || w(k), f } }(a))), Promise[n.__symbol__("uncaughtPromiseErrors")] = E, c }), Zone.__load_patch("toString", e => { const n = Function.prototype.toString, s = H("OriginalDelegate"), r = H("Promise"), i = H("Error"), l = function () { if ("function" == typeof this) { const v = this[s]; if (v) return "function" == typeof v ? n.call(v) : Object.prototype.toString.call(v); if (this === Promise) { const m = e[r]; if (m) return n.call(m) } if (this === Error) { const m = e[i]; if (m) return n.call(m) } } return n.call(this) }; l[s] = n, Function.prototype.toString = l; const p = Object.prototype.toString; Object.prototype.toString = function () { return "function" == typeof Promise && this instanceof Promise ? "[object Promise]" : p.call(this) } }); let Ee = !1; if (typeof window < "u") try { const e = Object.defineProperty({}, "passive", { get: function () { Ee = !0 } }); window.addEventListener("test", e, e), window.removeEventListener("test", e, e) } catch { Ee = !1 } const ht = { useG: !0 }, te = {}, ze = {}, Ye = new RegExp("^" + me + "(\\w+)(true|false)$"), $e = H("propagationStopped"); function Je(e, n) { const s = (n ? n(e) : e) + ce, r = (n ? n(e) : e) + ie, i = me + s, l = me + r; te[e] = {}, te[e][ce] = i, te[e][ie] = l } function dt(e, n, s, r) { const i = r && r.add || Ze, l = r && r.rm || De, p = r && r.listeners || "eventListeners", E = r && r.rmAll || "removeAllListeners", b = H(i), v = "." + i + ":", m = "prependListener", M = "." + m + ":", O = function (C, T, J) { if (C.isRemoved) return; const G = C.callback; let z; "object" == typeof G && G.handleEvent && (C.callback = y => G.handleEvent(y), C.originalDelegate = G); try { C.invoke(C, T, [J]) } catch (y) { z = y } const A = C.options; return A && "object" == typeof A && A.once && T[l].call(T, J.type, C.originalDelegate ? C.originalDelegate : C.callback, A), z }; function N(C, T, J) { if (!(T = T || e.event)) return; const G = C || T.target || e, z = G[te[T.type][J ? ie : ce]]; if (z) { const A = []; if (1 === z.length) { const y = O(z[0], G, T); y && A.push(y) } else { const y = z.slice(); for (let V = 0; V < y.length && (!T || !0 !== T[$e]); V++) { const d = O(y[V], G, T); d && A.push(d) } } if (1 === A.length) throw A[0]; for (let y = 0; y < A.length; y++) { const V = A[y]; n.nativeScheduleMicroTask(() => { throw V }) } } } const U = function (C) { return N(this, C, !1) }, x = function (C) { return N(this, C, !0) }; function K(C, T) { if (!C) return !1; let J = !0; T && void 0 !== T.useG && (J = T.useG); const G = T && T.vh; let z = !0; T && void 0 !== T.chkDup && (z = T.chkDup); let A = !1; T && void 0 !== T.rt && (A = T.rt); let y = C; for (; y && !y.hasOwnProperty(i);)y = ve(y); if (!y && C[i] && (y = C), !y || y[b]) return !1; const V = T && T.eventNameToString, d = {}, I = y[b] = y[i], P = y[H(l)] = y[l], Q = y[H(p)] = y[p], oe = y[H(E)] = y[E]; let Y; T && T.prepend && (Y = y[H(T.prepend)] = y[T.prepend]); const c = J ? function (o) { if (!d.isExisting) return I.call(d.target, d.eventName, d.capture ? x : U, d.options) } : function (o) { return I.call(d.target, d.eventName, o.invoke, d.options) }, t = J ? function (o) { if (!o.isRemoved) { const f = te[o.eventName]; let k; f && (k = f[o.capture ? ie : ce]); const R = k && o.target[k]; if (R) for (let g = 0; g < R.length; g++)if (R[g] === o) { R.splice(g, 1), o.isRemoved = !0, 0 === R.length && (o.allRemoved = !0, o.target[k] = null); break } } if (o.allRemoved) return P.call(o.target, o.eventName, o.capture ? x : U, o.options) } : function (o) { return P.call(o.target, o.eventName, o.invoke, o.options) }, w = T && T.diff ? T.diff : function (o, f) { const k = typeof f; return "function" === k && o.callback === f || "object" === k && o.originalDelegate === f }, L = Zone[H("UNPATCHED_EVENTS")], a = e[H("PASSIVE_EVENTS")], u = function (o, f, k, R, g = !1, S = !1) { return function () { const Z = this || e; let D = arguments[0]; T && T.transferEventName && (D = T.transferEventName(D)); let F = arguments[1]; if (!F) return o.apply(this, arguments); if (Pe && "uncaughtException" === D) return o.apply(this, arguments); let B = !1; if ("function" != typeof F) { if (!F.handleEvent) return o.apply(this, arguments); B = !0 } if (G && !G(o, F, Z, arguments)) return; const fe = Ee && !!a && -1 !== a.indexOf(D), se = function W(o, f) { return !Ee && "object" == typeof o && o ? !!o.capture : Ee && f ? "boolean" == typeof o ? { capture: o, passive: !0 } : o ? "object" == typeof o && !1 !== o.passive ? { ...o, passive: !0 } : o : { passive: !0 } : o }(arguments[2], fe); if (L) for (let de = 0; de < L.length; de++)if (D === L[de]) return fe ? o.call(Z, D, F, se) : o.apply(this, arguments); const xe = !!se && ("boolean" == typeof se || se.capture), tt = !(!se || "object" != typeof se) && se.once, kt = Zone.current; let Ge = te[D]; Ge || (Je(D, V), Ge = te[D]); const nt = Ge[xe ? ie : ce]; let Ce, ye = Z[nt], rt = !1; if (ye) { if (rt = !0, z) for (let de = 0; de < ye.length; de++)if (w(ye[de], F)) return } else ye = Z[nt] = []; const ot = Z.constructor.name, st = ze[ot]; st && (Ce = st[D]), Ce || (Ce = ot + f + (V ? V(D) : D)), d.options = se, tt && (d.options.once = !1), d.target = Z, d.capture = xe, d.eventName = D, d.isExisting = rt; const ke = J ? ht : void 0; ke && (ke.taskData = d); const he = kt.scheduleEventTask(Ce, F, ke, k, R); return d.target = null, ke && (ke.taskData = null), tt && (se.once = !0), !Ee && "boolean" == typeof he.options || (he.options = se), he.target = Z, he.capture = xe, he.eventName = D, B && (he.originalDelegate = F), S ? ye.unshift(he) : ye.push(he), g ? Z : void 0 } }; return y[i] = u(I, v, c, t, A), Y && (y[m] = u(Y, M, function (o) { return Y.call(d.target, d.eventName, o.invoke, d.options) }, t, A, !0)), y[l] = function () { const o = this || e; let f = arguments[0]; T && T.transferEventName && (f = T.transferEventName(f)); const k = arguments[2], R = !!k && ("boolean" == typeof k || k.capture), g = arguments[1]; if (!g) return P.apply(this, arguments); if (G && !G(P, g, o, arguments)) return; const S = te[f]; let Z; S && (Z = S[R ? ie : ce]); const D = Z && o[Z]; if (D) for (let F = 0; F < D.length; F++) { const B = D[F]; if (w(B, g)) return D.splice(F, 1), B.isRemoved = !0, 0 === D.length && (B.allRemoved = !0, o[Z] = null, "string" == typeof f) && (o[me + "ON_PROPERTY" + f] = null), B.zone.cancelTask(B), A ? o : void 0 } return P.apply(this, arguments) }, y[p] = function () { const o = this || e; let f = arguments[0]; T && T.transferEventName && (f = T.transferEventName(f)); const k = [], R = Ke(o, V ? V(f) : f); for (let g = 0; g < R.length; g++) { const S = R[g]; k.push(S.originalDelegate ? S.originalDelegate : S.callback) } return k }, y[E] = function () { const o = this || e; let f = arguments[0]; if (f) { T && T.transferEventName && (f = T.transferEventName(f)); const k = te[f]; if (k) { const S = o[k[ce]], Z = o[k[ie]]; if (S) { const D = S.slice(); for (let F = 0; F < D.length; F++) { const B = D[F]; this[l].call(this, f, B.originalDelegate ? B.originalDelegate : B.callback, B.options) } } if (Z) { const D = Z.slice(); for (let F = 0; F < D.length; F++) { const B = D[F]; this[l].call(this, f, B.originalDelegate ? B.originalDelegate : B.callback, B.options) } } } } else { const k = Object.keys(o); for (let R = 0; R < k.length; R++) { const S = Ye.exec(k[R]); let Z = S && S[1]; Z && "removeListener" !== Z && this[E].call(this, Z) } this[E].call(this, "removeListener") } if (A) return this }, le(y[i], I), le(y[l], P), oe && le(y[E], oe), Q && le(y[p], Q), !0 } let X = []; for (let C = 0; C < s.length; C++)X[C] = K(s[C], r); return X } function Ke(e, n) { if (!n) { const l = []; for (let p in e) { const E = Ye.exec(p); let b = E && E[1]; if (b && (!n || b === n)) { const v = e[p]; if (v) for (let m = 0; m < v.length; m++)l.push(v[m]) } } return l } let s = te[n]; s || (Je(n), s = te[n]); const r = e[s[ce]], i = e[s[ie]]; return r ? i ? r.concat(i) : r.slice() : i ? i.slice() : [] } function _t(e, n) { const s = e.Event; s && s.prototype && n.patchMethod(s.prototype, "stopImmediatePropagation", r => function (i, l) { i[$e] = !0, r && r.apply(i, l) }) } function Et(e, n, s, r, i) { const l = Zone.__symbol__(r); if (n[l]) return; const p = n[l] = n[r]; n[r] = function (E, b, v) { return b && b.prototype && i.forEach(function (m) { const M = `${s}.${r}::` + m, O = b.prototype; try { if (O.hasOwnProperty(m)) { const N = e.ObjectGetOwnPropertyDescriptor(O, m); N && N.value ? (N.value = e.wrapWithCurrentZone(N.value, M), e._redefineProperty(b.prototype, m, N)) : O[m] && (O[m] = e.wrapWithCurrentZone(O[m], M)) } else O[m] && (O[m] = e.wrapWithCurrentZone(O[m], M)) } catch { } }), p.call(n, E, b, v) }, e.attachOriginToPatched(n[r], p) } function Qe(e, n, s) { if (!s || 0 === s.length) return n; const r = s.filter(l => l.target === e); if (!r || 0 === r.length) return n; const i = r[0].ignoreProperties; return n.filter(l => -1 === i.indexOf(l)) } function et(e, n, s, r) { e && qe(e, Qe(e, n, s), r) } function He(e) { return Object.getOwnPropertyNames(e).filter(n => n.startsWith("on") && n.length > 2).map(n => n.substring(2)) } Zone.__load_patch("util", (e, n, s) => { const r = He(e); s.patchOnProperties = qe, s.patchMethod = ae, s.bindArguments = Le, s.patchMacroTask = lt; const i = n.__symbol__("BLACK_LISTED_EVENTS"), l = n.__symbol__("UNPATCHED_EVENTS"); e[l] && (e[i] = e[l]), e[i] && (n[i] = n[l] = e[i]), s.patchEventPrototype = _t, s.patchEventTarget = dt, s.isIEOrEdge = ft, s.ObjectDefineProperty = pe, s.ObjectGetOwnPropertyDescriptor = ue, s.ObjectCreate = Se, s.ArraySlice = it, s.patchClass = ge, s.wrapWithCurrentZone = Ie, s.filterProperties = Qe, s.attachOriginToPatched = le, s._redefineProperty = Object.defineProperty, s.patchCallbacks = Et, s.getGlobalObjects = () => ({ globalSources: ze, zoneSymbolEventNames: te, eventNames: r, isBrowser: Ae, isMix: Be, isNode: Pe, TRUE_STR: ie, FALSE_STR: ce, ZONE_SYMBOL_PREFIX: me, ADD_EVENT_LISTENER_STR: Ze, REMOVE_EVENT_LISTENER_STR: De }) }); const Re = H("zoneTask"); function Te(e, n, s, r) { let i = null, l = null; s += r; const p = {}; function E(v) { const m = v.data; return m.args[0] = function () { return v.invoke.apply(this, arguments) }, m.handleId = i.apply(e, m.args), v } function b(v) { return l.call(e, v.data.handleId) } i = ae(e, n += r, v => function (m, M) { if ("function" == typeof M[0]) { const O = { isPeriodic: "Interval" === r, delay: "Timeout" === r || "Interval" === r ? M[1] || 0 : void 0, args: M }, N = M[0]; M[0] = function () { try { return N.apply(this, arguments) } finally { O.isPeriodic || ("number" == typeof O.handleId ? delete p[O.handleId] : O.handleId && (O.handleId[Re] = null)) } }; const U = Me(n, M[0], O, E, b); if (!U) return U; const x = U.data.handleId; return "number" == typeof x ? p[x] = U : x && (x[Re] = U), x && x.ref && x.unref && "function" == typeof x.ref && "function" == typeof x.unref && (U.ref = x.ref.bind(x), U.unref = x.unref.bind(x)), "number" == typeof x || x ? x : U } return v.apply(e, M) }), l = ae(e, s, v => function (m, M) { const O = M[0]; let N; "number" == typeof O ? N = p[O] : (N = O && O[Re], N || (N = O)), N && "string" == typeof N.type ? "notScheduled" !== N.state && (N.cancelFn && N.data.isPeriodic || 0 === N.runCount) && ("number" == typeof O ? delete p[O] : O && (O[Re] = null), N.zone.cancelTask(N)) : v.apply(e, M) }) } Zone.__load_patch("legacy", e => { const n = e[Zone.__symbol__("legacyPatch")]; n && n() }), Zone.__load_patch("timers", e => { const n = "set", s = "clear"; Te(e, n, s, "Timeout"), Te(e, n, s, "Interval"), Te(e, n, s, "Immediate") }), Zone.__load_patch("requestAnimationFrame", e => { Te(e, "request", "cancel", "AnimationFrame"), Te(e, "mozRequest", "mozCancel", "AnimationFrame"), Te(e, "webkitRequest", "webkitCancel", "AnimationFrame") }), Zone.__load_patch("blocking", (e, n) => { const s = ["alert", "prompt", "confirm"]; for (let r = 0; r < s.length; r++)ae(e, s[r], (l, p, E) => function (b, v) { return n.current.run(l, e, v, E) }) }), Zone.__load_patch("EventTarget", (e, n, s) => { (function gt(e, n) { n.patchEventPrototype(e, n) })(e, s), function mt(e, n) { if (Zone[n.symbol("patchEventTarget")]) return; const { eventNames: s, zoneSymbolEventNames: r, TRUE_STR: i, FALSE_STR: l, ZONE_SYMBOL_PREFIX: p } = n.getGlobalObjects(); for (let b = 0; b < s.length; b++) { const v = s[b], O = p + (v + l), N = p + (v + i); r[v] = {}, r[v][l] = O, r[v][i] = N } const E = e.EventTarget; E && E.prototype && n.patchEventTarget(e, n, [E && E.prototype]) }(e, s); const r = e.XMLHttpRequestEventTarget; r && r.prototype && s.patchEventTarget(e, s, [r.prototype]) }), Zone.__load_patch("MutationObserver", (e, n, s) => { ge("MutationObserver"), ge("WebKitMutationObserver") }), Zone.__load_patch("IntersectionObserver", (e, n, s) => { ge("IntersectionObserver") }), Zone.__load_patch("FileReader", (e, n, s) => { ge("FileReader") }), Zone.__load_patch("on_property", (e, n, s) => { !function Tt(e, n) { if (Pe && !Be || Zone[e.symbol("patchEvents")]) return; const s = n.__Zone_ignore_on_properties; let r = []; if (Ae) { const i = window; r = r.concat(["Document", "SVGElement", "Element", "HTMLElement", "HTMLBodyElement", "HTMLMediaElement", "HTMLFrameSetElement", "HTMLFrameElement", "HTMLIFrameElement", "HTMLMarqueeElement", "Worker"]); const l = function ut() { try { const e = _e.navigator.userAgent; if (-1 !== e.indexOf("MSIE ") || -1 !== e.indexOf("Trident/")) return !0 } catch { } return !1 }() ? [{ target: i, ignoreProperties: ["error"] }] : []; et(i, He(i), s && s.concat(l), ve(i)) } r = r.concat(["XMLHttpRequest", "XMLHttpRequestEventTarget", "IDBIndex", "IDBRequest", "IDBOpenDBRequest", "IDBDatabase", "IDBTransaction", "IDBCursor", "WebSocket"]); for (let i = 0; i < r.length; i++) { const l = n[r[i]]; l && l.prototype && et(l.prototype, He(l.prototype), s) } }(s, e) }), Zone.__load_patch("customElements", (e, n, s) => { !function pt(e, n) { const { isBrowser: s, isMix: r } = n.getGlobalObjects(); (s || r) && e.customElements && "customElements" in e && n.patchCallbacks(n, e.customElements, "customElements", "define", ["connectedCallback", "disconnectedCallback", "adoptedCallback", "attributeChangedCallback"]) }(e, s) }), Zone.__load_patch("XHR", (e, n) => { !function b(v) { const m = v.XMLHttpRequest; if (!m) return; const M = m.prototype; let N = M[Oe], U = M[Ne]; if (!N) { const d = v.XMLHttpRequestEventTarget; if (d) { const I = d.prototype; N = I[Oe], U = I[Ne] } } const x = "readystatechange", K = "scheduled"; function X(d) { const I = d.data, P = I.target; P[l] = !1, P[E] = !1; const Q = P[i]; N || (N = P[Oe], U = P[Ne]), Q && U.call(P, x, Q); const oe = P[i] = () => { if (P.readyState === P.DONE) if (!I.aborted && P[l] && d.state === K) { const W = P[n.__symbol__("loadfalse")]; if (0 !== P.status && W && W.length > 0) { const re = d.invoke; d.invoke = function () { const ee = P[n.__symbol__("loadfalse")]; for (let q = 0; q < ee.length; q++)ee[q] === d && ee.splice(q, 1); !I.aborted && d.state === K && re.call(d) }, W.push(d) } else d.invoke() } else !I.aborted && !1 === P[l] && (P[E] = !0) }; return N.call(P, x, oe), P[s] || (P[s] = d), y.apply(P, I.args), P[l] = !0, d } function C() { } function T(d) { const I = d.data; return I.aborted = !0, V.apply(I.target, I.args) } const J = ae(M, "open", () => function (d, I) { return d[r] = 0 == I[2], d[p] = I[1], J.apply(d, I) }), z = H("fetchTaskAborting"), A = H("fetchTaskScheduling"), y = ae(M, "send", () => function (d, I) { if (!0 === n.current[A] || d[r]) return y.apply(d, I); { const P = { target: d, url: d[p], isPeriodic: !1, args: I, aborted: !1 }, Q = Me("XMLHttpRequest.send", C, P, X, T); d && !0 === d[E] && !P.aborted && Q.state === K && Q.invoke() } }), V = ae(M, "abort", () => function (d, I) { const P = function O(d) { return d[s] }(d); if (P && "string" == typeof P.type) { if (null == P.cancelFn || P.data && P.data.aborted) return; P.zone.cancelTask(P) } else if (!0 === n.current[z]) return V.apply(d, I) }) }(e); const s = H("xhrTask"), r = H("xhrSync"), i = H("xhrListener"), l = H("xhrScheduled"), p = H("xhrURL"), E = H("xhrErrorBeforeScheduled") }), Zone.__load_patch("geolocation", e => { e.navigator && e.navigator.geolocation && function at(e, n) { const s = e.constructor.name; for (let r = 0; r < n.length; r++) { const i = n[r], l = e[i]; if (l) { if (!Ve(ue(e, i))) continue; e[i] = (E => { const b = function () { return E.apply(this, Le(arguments, s + "." + i)) }; return le(b, E), b })(l) } } }(e.navigator.geolocation, ["getCurrentPosition", "watchPosition"]) }), Zone.__load_patch("PromiseRejectionEvent", (e, n) => { function s(r) { return function (i) { Ke(e, r).forEach(p => { const E = e.PromiseRejectionEvent; if (E) { const b = new E(r, { promise: i.promise, reason: i.rejection }); p.invoke(b) } }) } } e.PromiseRejectionEvent && (n[H("unhandledPromiseRejectionHandler")] = s("unhandledrejection"), n[H("rejectionHandledHandler")] = s("rejectionhandled")) }), Zone.__load_patch("queueMicrotask", (e, n, s) => { !function yt(e, n) { n.patchMethod(e, "queueMicrotask", s => function (r, i) { Zone.current.scheduleMicroTask("queueMicrotask", i[0]) }) }(e, s) }) } }, ue => { ue(ue.s = 332) }]); "use strict"; (self.webpackChunktinker_component = self.webpackChunktinker_component || []).push([[179], { 794: () => { function nr(e, t, n, r, o, i, s) { try { var a = e[i](s), u = a.value } catch (c) { return void n(c) } a.done ? t(u) : Promise.resolve(u).then(r, o) } function oe(e) { return "function" == typeof e } function ro(e) { const n = e(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const ts = ro(e => function (n) { e(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function ns(e, t) { if (e) { const n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } class tt { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const i of n) i.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (oe(r)) try { r() } catch (i) { t = i instanceof ts ? i.errors : [i] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const i of o) try { Fc(i) } catch (s) { t = t ?? [], s instanceof ts ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new ts(t) } } add(t) { var n; if (t && t !== this) if (this.closed) Fc(t); else { if (t instanceof tt) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && ns(n, t) } remove(t) { const { _finalizers: n } = this; n && ns(n, t), t instanceof tt && t._removeParent(this) } } tt.EMPTY = (() => { const e = new tt; return e.closed = !0, e })(); const Pc = tt.EMPTY; function Oc(e) { return e instanceof tt || e && "closed" in e && oe(e.remove) && oe(e.add) && oe(e.unsubscribe) } function Fc(e) { oe(e) ? e() : e.unsubscribe() } const $t = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, oo = { setTimeout(e, t, ...n) { const { delegate: r } = oo; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { const { delegate: t } = oo; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function kc(e) { oo.setTimeout(() => { const { onUnhandledError: t } = $t; if (!t) throw e; t(e) }) } function Lc() { } const Oy = rs("C", void 0, void 0); function rs(e, t, n) { return { kind: e, value: t, error: n } } let Ut = null; function io(e) { if ($t.useDeprecatedSynchronousErrorHandling) { const t = !Ut; if (t && (Ut = { errorThrown: !1, error: null }), e(), t) { const { errorThrown: n, error: r } = Ut; if (Ut = null, n) throw r } } else e() } class os extends tt { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, Oc(t) && t.add(this)) : this.destination = Hy } static create(t, n, r) { return new rr(t, n, r) } next(t) { this.isStopped ? ss(function ky(e) { return rs("N", e, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? ss(function Fy(e) { return rs("E", void 0, e) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? ss(Oy, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const jy = Function.prototype.bind; function is(e, t) { return jy.call(e, t) } class Vy { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { so(r) } } error(t) { const { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { so(r) } else so(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { so(n) } } } class rr extends os { constructor(t, n, r) { let o; if (super(), oe(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && $t.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && is(t.next, i), error: t.error && is(t.error, i), complete: t.complete && is(t.complete, i) }) : o = t } this.destination = new Vy(o) } } function so(e) { $t.useDeprecatedSynchronousErrorHandling ? function Ly(e) { $t.useDeprecatedSynchronousErrorHandling && Ut && (Ut.errorThrown = !0, Ut.error = e) }(e) : kc(e) } function ss(e, t) { const { onStoppedNotification: n } = $t; n && oo.setTimeout(() => n(e, t)) } const Hy = { closed: !0, next: Lc, error: function By(e) { throw e }, complete: Lc }, as = "function" == typeof Symbol && Symbol.observable || "@@observable"; function us(e) { return e } let Ie = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { const i = function Uy(e) { return e && e instanceof os || function $y(e) { return e && oe(e.next) && oe(e.error) && oe(e.complete) }(e) && Oc(e) }(n) ? n : new rr(n, r, o); return io(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = Vc(r))((o, i) => { const s = new rr({ next: a => { try { n(a) } catch (u) { i(u), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [as]() { return this } pipe(...n) { return function jc(e) { return 0 === e.length ? us : 1 === e.length ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } }(n)(this) } toPromise(n) { return new (n = Vc(n))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function Vc(e) { var t; return null !== (t = e ?? $t.Promise) && void 0 !== t ? t : Promise } const zy = ro(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let or = (() => { class e extends Ie { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new Bc(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new zy } next(n) { io(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { io(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { io(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? Pc : (this.currentObservers = null, i.push(n), new tt(() => { this.currentObservers = null, ns(i, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { const n = new Ie; return n.source = this, n } } return e.create = (t, n) => new Bc(t, n), e })(); class Bc extends or { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, t) } error(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, t) } complete() { var t, n; null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === n || n.call(t) } _subscribe(t) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t)) && void 0 !== r ? r : Pc } } class Gy extends or { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const n = super._subscribe(t); return !n.closed && t.next(this._value), n } getValue() { const { hasError: t, thrownError: n, _value: r } = this; if (t) throw n; return this._throwIfClosed(), r } next(t) { super.next(this._value = t) } } function zt(e) { return t => { if (function qy(e) { return oe(e?.lift) }(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Gt(e, t, n, r, o) { return new Wy(e, t, n, r, o) } class Wy extends os { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (u) { t.error(u) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (u) { t.error(u) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function Hc(e, t) { return zt((n, r) => { let o = 0; n.subscribe(Gt(r, i => { r.next(e.call(t, i, o++)) })) }) } function Nt(e) { return this instanceof Nt ? (this.v = e, this) : new Nt(e) } function Gc(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, t = e[Symbol.asyncIterator]; return t ? t.call(e) : (e = function fs(e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, u) { !function o(i, s, a, u) { Promise.resolve(u).then(function (c) { i({ value: c, done: a }) }, s) }(a, u, (s = e[i](s)).done, s.value) }) } } } "function" == typeof SuppressedError && SuppressedError; const qc = e => e && "number" == typeof e.length && "function" != typeof e; function Wc(e) { return oe(e?.then) } function Zc(e) { return oe(e[as]) } function Yc(e) { return Symbol.asyncIterator && oe(e?.[Symbol.asyncIterator]) } function Qc(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Kc = function gD() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function Xc(e) { return oe(e?.[Kc]) } function Jc(e) { return function zc(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = n.apply(e, t || []), i = []; return o = {}, s("next"), s("throw"), s("return"), o[Symbol.asyncIterator] = function () { return this }, o; function s(f) { r[f] && (o[f] = function (h) { return new Promise(function (p, g) { i.push([f, h, p, g]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function u(f) { f.value instanceof Nt ? Promise.resolve(f.value.v).then(c, l) : d(i[0][2], f) }(r[f](h)) } catch (p) { d(i[0][3], p) } } function c(f) { a("next", f) } function l(f) { a("throw", f) } function d(f, h) { f(h), i.shift(), i.length && a(i[0][0], i[0][1]) } }(this, arguments, function* () { const n = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield Nt(n.read()); if (o) return yield Nt(void 0); yield yield Nt(r) } } finally { n.releaseLock() } }) } function el(e) { return oe(e?.getReader) } function pt(e) { if (e instanceof Ie) return e; if (null != e) { if (Zc(e)) return function mD(e) { return new Ie(t => { const n = e[as](); if (oe(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (qc(e)) return function yD(e) { return new Ie(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) }(e); if (Wc(e)) return function DD(e) { return new Ie(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, kc) }) }(e); if (Yc(e)) return tl(e); if (Xc(e)) return function vD(e) { return new Ie(t => { for (const n of e) if (t.next(n), t.closed) return; t.complete() }) }(e); if (el(e)) return function _D(e) { return tl(Jc(e)) }(e) } throw Qc(e) } function tl(e) { return new Ie(t => { (function wD(e, t) { var n, r, o, i; return function $c(e, t, n, r) { return new (n || (n = Promise))(function (i, s) { function a(l) { try { c(r.next(l)) } catch (d) { s(d) } } function u(l) { try { c(r.throw(l)) } catch (d) { s(d) } } function c(l) { l.done ? i(l.value) : function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) }(l.value).then(a, u) } c((r = r.apply(e, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = Gc(e); !(r = yield n.next()).done;)if (t.next(r.value), t.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) })(e, t).catch(n => t.error(n)) }) } function xt(e, t, n, r = 0, o = !1) { const i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function nl(e, t, n = 1 / 0) { return oe(t) ? nl((r, o) => Hc((i, s) => t(r, i, o, s))(pt(e(r, o))), n) : ("number" == typeof t && (n = t), zt((r, o) => function ED(e, t, n, r, o, i, s, a) { const u = []; let c = 0, l = 0, d = !1; const f = () => { d && !u.length && !c && t.complete() }, h = g => c < r ? p(g) : u.push(g), p = g => { i && t.next(g), c++; let D = !1; pt(n(g, l++)).subscribe(Gt(t, v => { o?.(v), i ? h(v) : t.next(v) }, () => { D = !0 }, void 0, () => { if (D) try { for (c--; u.length && c < r;) { const v = u.shift(); s ? xt(t, s, () => p(v)) : p(v) } f() } catch (v) { t.error(v) } })) }; return e.subscribe(Gt(t, h, () => { d = !0, f() })), () => { a?.() } }(r, o, e, n))) } const rl = new Ie(e => e.complete()); function hs(e) { return e[e.length - 1] } function ol(e) { return function MD(e) { return e && oe(e.schedule) }(hs(e)) ? e.pop() : void 0 } function il(e, t = 0) { return zt((n, r) => { n.subscribe(Gt(r, o => xt(r, e, () => r.next(o), t), () => xt(r, e, () => r.complete(), t), o => xt(r, e, () => r.error(o), t))) }) } function sl(e, t = 0) { return zt((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function al(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new Ie(n => { xt(n, t, () => { const r = e[Symbol.asyncIterator](); xt(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function ul(e, t) { return t ? function RD(e, t) { if (null != e) { if (Zc(e)) return function SD(e, t) { return pt(e).pipe(sl(t), il(t)) }(e, t); if (qc(e)) return function AD(e, t) { return new Ie(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) }(e, t); if (Wc(e)) return function TD(e, t) { return pt(e).pipe(sl(t), il(t)) }(e, t); if (Yc(e)) return al(e, t); if (Xc(e)) return function ND(e, t) { return new Ie(n => { let r; return xt(n, t, () => { r = e[Kc](), xt(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void n.error(s) } i ? n.complete() : n.next(o) }, 0, !0) }), () => oe(r?.return) && r.return() }) }(e, t); if (el(e)) return function xD(e, t) { return al(Jc(e), t) }(e, t) } throw Qc(e) }(e, t) : pt(e) } function cl(...e) { const t = ol(e), n = function bD(e, t) { return "number" == typeof hs(e) ? e.pop() : t }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? pt(r[0]) : function CD(e = 1 / 0) { return nl(us, e) }(n)(ul(r, t)) : rl } function ll(e = {}) { const { connector: t = (() => new or), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = e; return i => { let s, a, u, c = 0, l = !1, d = !1; const f = () => { a?.unsubscribe(), a = void 0 }, h = () => { f(), s = u = void 0, l = d = !1 }, p = () => { const g = s; h(), g?.unsubscribe() }; return zt((g, D) => { c++, !d && !l && f(); const v = u = u ?? t(); D.add(() => { c--, 0 === c && !d && !l && (a = ps(p, o)) }), v.subscribe(D), !s && c > 0 && (s = new rr({ next: m => v.next(m), error: m => { d = !0, f(), a = ps(h, n, m), v.error(m) }, complete: () => { l = !0, f(), a = ps(h, r), v.complete() } }), pt(g).subscribe(s)) })(i) } } function ps(e, t, ...n) { if (!0 === t) return void e(); if (!1 === t) return; const r = new rr({ next: () => { r.unsubscribe(), e() } }); return pt(t(...n)).subscribe(r) } function dl(e, t) { return zt((n, r) => { let o = null, i = 0, s = !1; const a = () => s && !o && r.complete(); n.subscribe(Gt(r, u => { o?.unsubscribe(); let c = 0; const l = i++; pt(e(u, l)).subscribe(o = Gt(r, d => r.next(t ? t(u, d, l, c++) : d), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function FD(e, t) { return e === t } function U(e) { for (let t in e) if (e[t] === U) return t; throw Error("Could not find renamed property on target object.") } function ae(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(ae).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function gs(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const kD = U({ __forward_ref__: U }); function ms(e) { return e.__forward_ref__ = ms, e.toString = function () { return ae(this()) }, e } function b(e) { return function ys(e) { return "function" == typeof e && e.hasOwnProperty(kD) && e.__forward_ref__ === ms }(e) ? e() : e } function Ds(e) { return e && !!e.\u0275providers } class w extends Error { constructor(t, n) { super(function uo(e, t) { return `NG0${Math.abs(e)}${t ? ": " + t : ""}` }(t, n)), this.code = t } } function $(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : function S(e) { return "string" == typeof e ? e : null == e ? "" : String(e) }(e) } function vs(e, t) { throw new w(-201, !1) } function Be(e, t) { null == e && function C(e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) }(t, e, null, "!=") } function z(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function co(e) { return { providers: e.providers || [], imports: e.imports || [] } } function lo(e) { return hl(e, ho) || hl(e, pl) } function hl(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function fo(e) { return e && (e.hasOwnProperty(_s) || e.hasOwnProperty(UD)) ? e[_s] : null } const ho = U({ \u0275prov: U }), _s = U({ \u0275inj: U }), pl = U({ ngInjectableDef: U }), UD = U({ ngInjectorDef: U }); var F = function (e) { return e[e.Default = 0] = "Default", e[e.Host = 1] = "Host", e[e.Self = 2] = "Self", e[e.SkipSelf = 4] = "SkipSelf", e[e.Optional = 8] = "Optional", e }(F || {}); let ws; function Me(e) { const t = ws; return ws = e, t } function ml(e, t, n) { const r = lo(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & F.Optional ? null : void 0 !== t ? t : void vs(ae(e)) } const G = globalThis, ir = {}, bs = "__NG_DI_FLAG__", po = "ngTempTokenPath", qD = /\n/gm, Dl = "__source"; let an; function Rt(e) { const t = an; return an = e, t } function YD(e, t = F.Default) { if (void 0 === an) throw new w(-203, !1); return null === an ? ml(e, void 0, t) : an.get(e, t & F.Optional ? null : void 0, t) } function j(e, t = F.Default) { return (function gl() { return ws }() || YD)(b(e), t) } function W(e, t = F.Default) { return j(e, go(t)) } function go(e) { return typeof e > "u" || "number" == typeof e ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function Ss(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = b(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new w(900, !1); let o, i = F.Default; for (let s = 0; s < r.length; s++) { const a = r[s], u = QD(a); "number" == typeof u ? -1 === u ? o = a.token : i |= u : o = a } t.push(j(o, i)) } else t.push(j(r)) } return t } function QD(e) { return e[bs] } function gt(e) { return { toString: e }.toString() } var mo = function (e) { return e[e.OnPush = 0] = "OnPush", e[e.Default = 1] = "Default", e }(mo || {}), qe = function (e) { return e[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", e }(qe || {}); const nt = {}, V = [], yo = U({ \u0275cmp: U }), Ts = U({ \u0275dir: U }), As = U({ \u0275pipe: U }), mt = U({ \u0275fac: U }), ar = U({ __NG_ELEMENT_ID__: U }), wl = U({ __NG_ENV_ID__: U }); function El(e, t, n) { let r = e.length; for (; ;) { const o = e.indexOf(t, n); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } function Ns(e, t, n) { let r = 0; for (; r < n.length;) { const o = n[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { const i = o, s = n[++r]; Il(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function Cl(e) { return 3 === e || 4 === e || 6 === e } function Il(e) { return 64 === e.charCodeAt(0) } function ur(e, t) { if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const o = t[r]; "number" == typeof o ? n = o : 0 === n || Ml(e, n, o, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function Ml(e, t, n, r, o) { let i = 0, s = e.length; if (-1 === t) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } const bl = "ng-template"; function JD(e, t, n) { let r = 0, o = !0; for (; r < e.length;) { let i = e[r++]; if ("string" == typeof i && o) { const s = e[r++]; if (n && "class" === i && -1 !== El(s.toLowerCase(), t, 0)) return !0 } else { if (1 === i) { for (; r < e.length && "string" == typeof (i = e[r++]);)if (i.toLowerCase() === t) return !0; return !1 } "number" == typeof i && (o = !1) } } return !1 } function Sl(e) { return 4 === e.type && e.value !== bl } function ev(e, t, n) { return t === (4 !== e.type || n ? e.value : bl) } function tv(e, t, n) { let r = 4; const o = e.attrs || [], i = function ov(e) { for (let t = 0; t < e.length; t++)if (Cl(e[t])) return t; return e.length }(o); let s = !1; for (let a = 0; a < t.length; a++) { const u = t[a]; if ("number" != typeof u) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== u && !ev(e, u, n) || "" === u && 1 === t.length) { if (We(r)) return !1; s = !0 } } else { const c = 8 & r ? u : t[++a]; if (8 & r && null !== e.attrs) { if (!JD(e.attrs, c, n)) { if (We(r)) return !1; s = !0 } continue } const d = nv(8 & r ? "class" : u, o, Sl(e), n); if (-1 === d) { if (We(r)) return !1; s = !0; continue } if ("" !== c) { let f; f = d > i ? "" : o[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== El(h, c, 0) || 2 & r && c !== f) { if (We(r)) return !1; s = !0 } } } } else { if (!s && !We(r) && !We(u)) return !1; if (s && We(u)) continue; s = !1, r = u | 1 & r } } return We(r) || s } function We(e) { return 0 == (1 & e) } function nv(e, t, n, r) { if (null === t) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { const s = t[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = t[++o]; for (; "string" == typeof a;)a = t[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function iv(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function Tl(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (tv(e, t[r], n)) return !0; return !1 } function Al(e, t) { return e ? ":not(" + t.trim() + ")" : t } function av(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if ("string" == typeof s) if (2 & r) { const a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !We(s) && (t += Al(i, o), o = ""), r = s, i = i || !We(r); n++ } return "" !== o && (t += Al(i, o)), t } function Nl(e) { return gt(() => { const t = function Rl(e) { const t = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: t, inputTransforms: null, inputConfig: e.inputs || nt, exportAs: e.exportAs || null, standalone: !0 === e.standalone, signals: !0 === e.signals, selectors: e.selectors || V, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: xl(e.inputs, t), outputs: xl(e.outputs) } }(e), n = { ...t, decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === mo.OnPush, directiveDefs: null, pipeDefs: null, dependencies: t.standalone && e.dependencies || null, getStandaloneInjector: null, signals: e.signals ?? !1, data: e.data || {}, encapsulation: e.encapsulation || qe.Emulated, styles: e.styles || V, _: null, schemas: e.schemas || null, tView: null, id: "" }; !function Pl(e) { e.features?.forEach(t => t(e)) }(n); const r = e.dependencies; return n.directiveDefs = Do(r, !1), n.pipeDefs = Do(r, !0), n.id = function gv(e) { let t = 0; const n = [e.selectors, e.ngContentSelectors, e.hostVars, e.hostAttrs, e.consts, e.vars, e.decls, e.encapsulation, e.standalone, e.signals, e.exportAs, JSON.stringify(e.inputs), JSON.stringify(e.outputs), Object.getOwnPropertyNames(e.type.prototype), !!e.contentQueries, !!e.viewQuery].join("|"); for (const o of n) t = Math.imul(31, t) + o.charCodeAt(0) << 0; return t += 2147483648, "c" + t }(n), n }) } function dv(e) { return k(e) || de(e) } function fv(e) { return null !== e } function xs(e) { return gt(() => ({ type: e.type, bootstrap: e.bootstrap || V, declarations: e.declarations || V, imports: e.imports || V, exports: e.exports || V, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function xl(e, t) { if (null == e) return nt; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let o = e[r], i = o; Array.isArray(o) && (i = o[1], o = o[0]), n[o] = r, t && (t[o] = i) } return n } function k(e) { return e[yo] || null } function de(e) { return e[Ts] || null } function ye(e) { return e[As] || null } function Do(e, t) { if (!e) return null; const n = t ? ye : dv; return () => ("function" == typeof e ? e() : e).map(r => n(r)).filter(fv) } const ee = 0, _ = 1, A = 2, K = 3, Ze = 4, lr = 5, pe = 6, un = 7, te = 8, Pt = 9, cn = 10, T = 11, dr = 12, Ol = 13, ln = 14, ne = 15, fr = 16, dn = 17, rt = 18, hr = 19, Fl = 20, Ot = 21, yt = 22, vo = 23, _o = 24, P = 25, Rs = 1, kl = 2, ot = 7, fn = 9, fe = 11; function Se(e) { return Array.isArray(e) && "object" == typeof e[Rs] } function Te(e) { return Array.isArray(e) && !0 === e[Rs] } function Ps(e) { return 0 != (4 & e.flags) } function Wt(e) { return e.componentOffset > -1 } function Ye(e) { return !!e.template } function Os(e) { return 0 != (512 & e[A]) } function Zt(e, t) { return e.hasOwnProperty(mt) ? e[mt] : null } let wv = G.WeakRef ?? class _v { constructor(t) { this.ref = t } deref() { return this.ref } }, Cv = 0, it = null, Co = !1; function le(e) { const t = it; return it = e, t } class Hl { constructor() { this.id = Cv++, this.ref = function Ev(e) { return new wv(e) }(this), this.producers = new Map, this.consumers = new Map, this.trackingVersion = 0, this.valueVersion = 0 } consumerPollProducersForChange() { for (const [t, n] of this.producers) { const r = n.producerNode.deref(); if (null != r && n.atTrackingVersion === this.trackingVersion) { if (r.producerPollStatus(n.seenValueVersion)) return !0 } else this.producers.delete(t), r?.consumers.delete(this.id) } return !1 } producerMayHaveChanged() { const t = Co; Co = !0; try { for (const [n, r] of this.consumers) { const o = r.consumerNode.deref(); null != o && o.trackingVersion === r.atTrackingVersion ? o.onConsumerDependencyMayHaveChanged() : (this.consumers.delete(n), o?.producers.delete(this.id)) } } finally { Co = t } } producerAccessed() { if (Co) throw new Error(""); if (null === it) return; let t = it.producers.get(this.id); void 0 === t ? (t = { consumerNode: it.ref, producerNode: this.ref, seenValueVersion: this.valueVersion, atTrackingVersion: it.trackingVersion }, it.producers.set(this.id, t), this.consumers.set(it.id, t)) : (t.seenValueVersion = this.valueVersion, t.atTrackingVersion = it.trackingVersion) } get hasProducers() { return this.producers.size > 0 } get producerUpdatesAllowed() { return !1 !== it?.consumerAllowSignalWrites } producerPollStatus(t) { return this.valueVersion !== t || (this.onProducerUpdateValueVersion(), this.valueVersion !== t) } } let $l = null; const zl = () => { }; class Sv extends Hl { constructor(t, n, r) { super(), this.watch = t, this.schedule = n, this.dirty = !1, this.cleanupFn = zl, this.registerOnCleanup = o => { this.cleanupFn = o }, this.consumerAllowSignalWrites = r } notify() { this.dirty || this.schedule(this), this.dirty = !0 } onConsumerDependencyMayHaveChanged() { this.notify() } onProducerUpdateValueVersion() { } run() { if (this.dirty = !1, 0 !== this.trackingVersion && !this.consumerPollProducersForChange()) return; const t = le(this); this.trackingVersion++; try { this.cleanupFn(), this.cleanupFn = zl, this.watch(this.registerOnCleanup) } finally { le(t) } } cleanup() { this.cleanupFn() } } class Gl { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function ql(e) { return e.type.prototype.ngOnChanges && (e.setInput = Av), Tv } function Tv() { const e = Zl(this), t = e?.current; if (t) { const n = e.previous; if (n === nt) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function Av(e, t, n, r) { const o = this.declaredInputs[n], i = Zl(e) || function Nv(e, t) { return e[Wl] = t }(e, { previous: nt, current: null }), s = i.current || (i.current = {}), a = i.previous, u = a[o]; s[o] = new Gl(u && u.currentValue, t, a === nt), e[r] = t } const Wl = "__ngSimpleChanges__"; function Zl(e) { return e[Wl] || null } const st = function (e, t, n) { }; function Z(e) { for (; Array.isArray(e);)e = e[ee]; return e } function Ae(e, t) { return Z(t[e.index]) } function ke(e, t) { const n = t[e]; return Se(n) ? n : n[ee] } function Ft(e, t) { return null == t ? null : e[t] } function Xl(e) { e[dn] = 0 } function Lv(e) { 1024 & e[A] || (e[A] |= 1024, ed(e, 1)) } function Jl(e) { 1024 & e[A] && (e[A] &= -1025, ed(e, -1)) } function ed(e, t) { let n = e[K]; if (null === n) return; n[lr] += t; let r = n; for (n = n[K]; null !== n && (1 === t && 1 === r[lr] || -1 === t && 0 === r[lr]);)n[lr] += t, r = n, n = n[K] } const I = { lFrame: dd(null), bindingsEnabled: !0, skipHydrationRootTNode: null }; function rd() { return I.bindingsEnabled } function y() { return I.lFrame.lView } function L() { return I.lFrame.tView } function he() { let e = od(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function od() { return I.lFrame.currentTNode } function at(e, t) { const n = I.lFrame; n.currentTNode = e, n.isParent = t } function Bs() { return I.lFrame.isParent } function Kv(e, t) { const n = I.lFrame; n.bindingIndex = n.bindingRootIndex = e, $s(t) } function $s(e) { I.lFrame.currentDirectiveIndex = e } function zs(e) { I.lFrame.currentQueryIndex = e } function Jv(e) { const t = e[_]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[pe] : null } function cd(e, t, n) { if (n & F.SkipSelf) { let o = t, i = e; for (; !(o = o.parent, null !== o || n & F.Host || (o = Jv(i), null === o || (i = i[ln], 10 & o.type)));); if (null === o) return !1; t = o, e = i } const r = I.lFrame = ld(); return r.currentTNode = t, r.lView = e, !0 } function Gs(e) { const t = ld(), n = e[_]; I.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function ld() { const e = I.lFrame, t = null === e ? null : e.child; return null === t ? dd(e) : t } function dd(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function fd() { const e = I.lFrame; return I.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const hd = fd; function qs() { const e = fd(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function Yt(e) { I.lFrame.selectedIndex = e } let gd = !0; function To() { return gd } function kt(e) { gd = e } function Ao(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: u, ngAfterViewChecked: c, ngOnDestroy: l } = i; s && (e.contentHooks ??= []).push(-n, s), a && ((e.contentHooks ??= []).push(n, a), (e.contentCheckHooks ??= []).push(n, a)), u && (e.viewHooks ??= []).push(-n, u), c && ((e.viewHooks ??= []).push(n, c), (e.viewCheckHooks ??= []).push(n, c)), null != l && (e.destroyHooks ??= []).push(n, l) } } function No(e, t, n) { md(e, t, 3, n) } function xo(e, t, n, r) { (3 & e[A]) === n && md(e, t, n, r) } function Ws(e, t) { let n = e[A]; (3 & n) === t && (n &= 8191, n += 1, e[A] = n) } function md(e, t, n, r) { const i = r ?? -1, s = t.length - 1; let a = 0; for (let u = void 0 !== r ? 65535 & e[dn] : 0; u < s; u++)if ("number" == typeof t[u + 1]) { if (a = t[u], null != r && a >= r) break } else t[u] < 0 && (e[dn] += 65536), (a < i || -1 == i) && (a_(e, n, t, u), e[dn] = (4294901760 & e[dn]) + u + 2), u++ } function yd(e, t) { st(4, e, t); const n = le(null); try { t.call(e) } finally { le(n), st(5, e, t) } } function a_(e, t, n, r) { const o = n[r] < 0, i = n[r + 1], a = e[o ? -n[r] : n[r]]; o ? e[A] >> 13 < e[dn] >> 16 && (3 & e[A]) === t && (e[A] += 8192, yd(a, i)) : yd(a, i) } const mn = -1; class mr { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function yr(e) { return 32767 & e } function Dr(e, t) { let n = function d_(e) { return e >> 16 }(e), r = t; for (; n > 0;)r = r[ln], n--; return r } let Qs = !0; function Ro(e) { const t = Qs; return Qs = e, t } const Dd = 255, vd = 5; let f_ = 0; const ut = {}; function Po(e, t) { const n = _d(e, t); if (-1 !== n) return n; const r = t[_]; r.firstCreatePass && (e.injectorIndex = t.length, Ks(r.data, e), Ks(t, null), Ks(r.blueprint, null)); const o = Oo(e, t), i = e.injectorIndex; if (function Ys(e) { return e !== mn }(o)) { const s = yr(o), a = Dr(o, t), u = a[_].data; for (let c = 0; c < 8; c++)t[i + c] = a[s + c] | u[s + c] } return t[i + 8] = o, i } function Ks(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function _d(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function Oo(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; null !== o;) { if (r = Sd(o), null === r) return mn; if (n++, o = o[ln], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return mn } function Xs(e, t, n) { !function h_(e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(ar) && (r = n[ar]), null == r && (r = n[ar] = f_++); const o = r & Dd; t.data[e + (o >> vd)] |= 1 << o }(e, t, n) } function wd(e, t, n) { if (n & F.Optional || void 0 !== e) return e; vs() } function Ed(e, t, n, r) { if (n & F.Optional && void 0 === r && (r = null), !(n & (F.Self | F.Host))) { const o = e[Pt], i = Me(void 0); try { return o ? o.get(t, r, n & F.Optional) : ml(t, r, n & F.Optional) } finally { Me(i) } } return wd(r, 0, n) } function Cd(e, t, n, r = F.Default, o) { if (null !== e) { if (2048 & t[A] && !(r & F.Self)) { const s = function __(e, t, n, r, o) { let i = e, s = t; for (; null !== i && null !== s && 2048 & s[A] && !(512 & s[A]);) { const a = Id(i, s, n, r | F.Self, ut); if (a !== ut) return a; let u = i.parent; if (!u) { const c = s[Fl]; if (c) { const l = c.get(n, ut, r); if (l !== ut) return l } u = Sd(s), s = s[ln] } i = u } return o }(e, t, n, r, ut); if (s !== ut) return s } const i = Id(e, t, n, r, ut); if (i !== ut) return i } return Ed(t, n, r, o) } function Id(e, t, n, r, o) { const i = function m_(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(ar) ? e[ar] : void 0; return "number" == typeof t ? t >= 0 ? t & Dd : D_ : t }(n); if ("function" == typeof i) { if (!cd(t, e, r)) return r & F.Host ? wd(o, 0, r) : Ed(t, n, r, o); try { let s; if (s = i(r), null != s || r & F.Optional) return s; vs() } finally { hd() } } else if ("number" == typeof i) { let s = null, a = _d(e, t), u = mn, c = r & F.Host ? t[ne][pe] : null; for ((-1 === a || r & F.SkipSelf) && (u = -1 === a ? Oo(e, t) : t[a + 8], u !== mn && bd(r, !1) ? (s = t[_], a = yr(u), t = Dr(u, t)) : a = -1); -1 !== a;) { const l = t[_]; if (Md(i, a, l.data)) { const d = g_(a, t, n, s, r, c); if (d !== ut) return d } u = t[a + 8], u !== mn && bd(r, t[_].data[a + 8] === c) && Md(i, a, t) ? (s = l, a = yr(u), t = Dr(u, t)) : a = -1 } } return o } function g_(e, t, n, r, o, i) { const s = t[_], a = s.data[e + 8], l = function Fo(e, t, n, r, o) { const i = e.providerIndexes, s = t.data, a = 1048575 & i, u = e.directiveStart, l = i >> 20, f = o ? a + l : e.directiveEnd; for (let h = r ? a : a + l; h < f; h++) { const p = s[h]; if (h < u && n === p || h >= u && p.type === n) return h } if (o) { const h = s[u]; if (h && Ye(h) && h.type === n) return u } return null }(a, s, n, null == r ? Wt(a) && Qs : r != s && 0 != (3 & a.type), o & F.Host && i === a); return null !== l ? Qt(t, s, l, a) : ut } function Qt(e, t, n, r) { let o = e[n]; const i = t.data; if (function u_(e) { return e instanceof mr }(o)) { const s = o; s.resolving && function LD(e, t) { const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : ""; throw new w(-200, `Circular dependency in DI detected for ${e}${n}`) }($(i[n])); const a = Ro(s.canSeeViewProviders); s.resolving = !0; const c = s.injectImpl ? Me(s.injectImpl) : null; cd(e, r, F.Default); try { o = e[n] = s.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && function s_(e, t, n) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { const s = ql(t); (n.preOrderHooks ??= []).push(e, s), (n.preOrderCheckHooks ??= []).push(e, s) } o && (n.preOrderHooks ??= []).push(0 - e, o), i && ((n.preOrderHooks ??= []).push(e, i), (n.preOrderCheckHooks ??= []).push(e, i)) }(n, i[n], t) } finally { null !== c && Me(c), Ro(a), s.resolving = !1, hd() } } return o } function Md(e, t, n) { return !!(n[t + (e >> vd)] & 1 << e) } function bd(e, t) { return !(e & F.Self || e & F.Host && t) } class _e { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return Cd(this._tNode, this._lView, t, go(r), n) } } function D_() { return new _e(he(), y()) } function Sd(e) { const t = e[_], n = t.type; return 2 === n ? t.declTNode : 1 === n ? e[pe] : null } function En(e, t) { e.forEach(n => Array.isArray(n) ? En(n, t) : t(n)) } function ko(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } var Lt = function (e) { return e[e.Important = 1] = "Important", e[e.DashCase = 2] = "DashCase", e }(Lt || {}); const ca = new Map; let K_ = 0; const da = "__ngContext__"; function ge(e, t) { Se(t) ? (e[da] = t[hr], function J_(e) { ca.set(e[hr], e) }(t)) : e[da] = t } let fa; function ha(e, t) { return fa(e, t) } function Ir(e) { const t = e[K]; return Te(t) ? t[K] : t } function Qd(e) { return Xd(e[dr]) } function Kd(e) { return Xd(e[Ze]) } function Xd(e) { for (; null !== e && !Te(e);)e = e[Ze]; return e } function bn(e, t, n, r, o) { if (null != r) { let i, s = !1; Te(r) ? i = r : Se(r) && (s = !0, r = r[ee]); const a = Z(r); 0 === e && null !== n ? null == o ? nf(t, n, a) : Kt(t, n, a, o || null, !0) : 1 === e && null !== n ? Kt(t, n, a, o || null, !0) : 2 === e ? function Yo(e, t, n) { const r = function Wo(e, t) { return e.parentNode(t) }(e, t); r && function Dw(e, t, n, r) { e.removeChild(t, n, r) }(e, r, t, n) }(t, a, s) : 3 === e && t.destroyNode(a), null != i && function ww(e, t, n, r, o) { const i = n[ot]; i !== Z(n) && bn(t, e, r, i, o); for (let a = fe; a < n.length; a++) { const u = n[a]; br(u[_], u, e, t, r, i) } }(t, e, i, n, o) } } function Go(e, t, n) { return e.createElement(t, n) } function ef(e, t) { const n = e[fn], r = n.indexOf(t); Jl(t), n.splice(r, 1) } function ma(e, t) { if (!(256 & t[A])) { t[A] &= -129, t[A] |= 256, function yw(e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const o = t[n[r]]; if (!(o instanceof mr)) { const i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], u = i[s + 1]; st(4, a, u); try { u.call(a) } finally { st(5, a, u) } } else { st(4, o, i); try { i.call(o) } finally { st(5, o, i) } } } } }(e, t), function mw(e, t) { const n = e.cleanup, r = t[un]; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const s = n[i + 3]; s >= 0 ? r[s]() : r[-s].unsubscribe(), i += 2 } else n[i].call(r[n[i + 1]]); null !== r && (t[un] = null); const o = t[Ot]; if (null !== o) { t[Ot] = null; for (let i = 0; i < o.length; i++)(0, o[i])() } }(e, t), 1 === t[_].type && t[T].destroy(); const n = t[fr]; if (null !== n && Te(t[K])) { n !== t[K] && ef(n, t); const r = t[rt]; null !== r && r.detachView(e) } !function ew(e) { ca.delete(e[hr]) }(t) } } function ya(e, t, n) { return function tf(e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[ee]; { const { componentOffset: o } = r; if (o > -1) { const { encapsulation: i } = e.data[r.directiveStart + o]; if (i === qe.None || i === qe.Emulated) return null } return Ae(r, n) } }(e, t.parent, n) } function Kt(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function nf(e, t, n) { e.appendChild(t, n) } function rf(e, t, n, r, o) { null !== r ? Kt(e, t, n, r, o) : nf(e, t, n) } let Da, Ea, af = function sf(e, t, n) { return 40 & e.type ? Ae(e, n) : null }; function Zo(e, t, n, r) { const o = ya(e, r, t), i = t[T], a = function of(e, t, n) { return af(e, t, n) }(r.parent || t[pe], r, t); if (null != o) if (Array.isArray(n)) for (let u = 0; u < n.length; u++)rf(i, o, n[u], a, !1); else rf(i, o, n, a, !1); void 0 !== Da && Da(i, r, t, n, o) } function cf(e, t) { return null !== t ? e[ne][pe].projection[t.projection] : null } function _a(e, t, n, r, o, i, s) { for (; null != n;) { const a = r[n.index], u = n.type; if (s && 0 === t && (a && ge(Z(a), r), n.flags |= 2), 32 != (32 & n.flags)) if (8 & u) _a(e, t, n.child, r, o, i, !1), bn(t, e, o, a, i); else if (32 & u) { const c = ha(n, r); let l; for (; l = c();)bn(t, e, o, l, i); bn(t, e, o, a, i) } else 16 & u ? df(e, t, r, n, o, i) : bn(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function br(e, t, n, r, o, i) { _a(n, r, e.firstChild, t, o, i, !1) } function df(e, t, n, r, o, i) { const s = n[ne], u = s[pe].projection[r.projection]; if (Array.isArray(u)) for (let c = 0; c < u.length; c++)bn(t, e, o, u[c], i); else { let c = u; const l = s[K]; (function $o(e) { return 128 == (128 & e.flags) })(r) && (c.flags |= 128), _a(e, t, c, l, o, i, !0) } } function ff(e, t, n) { "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function hf(e, t, n) { const { mergedAttrs: r, classes: o, styles: i } = n; null !== r && Ns(e, t, r), null !== o && ff(e, t, o), null !== i && function Cw(e, t, n) { e.setAttribute(t, "style", n) }(e, t, i) } class N { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = z({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } const Jo = new N("ENVIRONMENT_INITIALIZER"), bf = new N("INJECTOR", -1), Sf = new N("INJECTOR_DEF_TYPES"); class Ta { get(t, n = ir) { if (n === ir) { const r = new Error(`NullInjectorError: No provider for ${ae(t)}!`); throw r.name = "NullInjectorError", r } return n } } function Kw(...e) { return { \u0275providers: Af(0, e), \u0275fromNgModule: !0 } } function Af(e, ...t) { const n = [], r = new Set; let o; const i = s => { n.push(s) }; return En(t, s => { const a = s; ei(a, i, [], r) && (o ||= [], o.push(a)) }), void 0 !== o && Nf(o, i), n } function Nf(e, t) { for (let n = 0; n < e.length; n++) { const { ngModule: r, providers: o } = e[n]; Aa(o, i => { t(i, r) }) } } function ei(e, t, n, r) { if (!(e = b(e))) return !1; let o = null, i = fo(e); const s = !i && k(e); if (i || s) { if (s && !s.standalone) return !1; o = e } else { const u = e.ngModule; if (i = fo(u), !i) return !1; o = u } const a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { const u = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const c of u) ei(c, t, n, r) } } else { if (!i) return !1; { if (null != i.imports && !a) { let c; r.add(o); try { En(i.imports, l => { ei(l, t, n, r) && (c ||= [], c.push(l)) }) } finally { } void 0 !== c && Nf(c, t) } if (!a) { const c = Zt(o) || (() => new o); t({ provide: o, useFactory: c, deps: V }, o), t({ provide: Sf, useValue: o, multi: !0 }, o), t({ provide: Jo, useValue: () => j(o), multi: !0 }, o) } const u = i.providers; if (null != u && !a) { const c = e; Aa(u, l => { t(l, c) }) } } } return o !== e && void 0 !== e.providers } function Aa(e, t) { for (let n of e) Ds(n) && (n = n.\u0275providers), Array.isArray(n) ? Aa(n, t) : t(n) } const Xw = U({ provide: String, useValue: U }); function Na(e) { return null !== e && "object" == typeof e && Xw in e } function Xt(e) { return "function" == typeof e } const xa = new N("Set Injector scope."), ti = {}, eE = {}; let Ra; function ni() { return void 0 === Ra && (Ra = new Ta), Ra } class wt { } class ri extends wt { get destroyed() { return this._destroyed } constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Oa(t, s => this.processProvider(s)), this.records.set(bf, Nn(void 0, this)), o.has("environment") && this.records.set(wt, Nn(void 0, this)); const i = this.records.get(xa); null != i && "string" == typeof i.value && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(Sf.multi, V, F.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const n of this._ngOnDestroyHooks) n.ngOnDestroy(); const t = this._onDestroyHooks; this._onDestroyHooks = []; for (const n of t) n() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear() } } onDestroy(t) { return this.assertNotDestroyed(), this._onDestroyHooks.push(t), () => this.removeOnDestroy(t) } runInContext(t) { this.assertNotDestroyed(); const n = Rt(this), r = Me(void 0); try { return t() } finally { Rt(n), Me(r) } } get(t, n = ir, r = F.Default) { if (this.assertNotDestroyed(), t.hasOwnProperty(wl)) return t[wl](this); r = go(r); const i = Rt(this), s = Me(void 0); try { if (!(r & F.SkipSelf)) { let u = this.records.get(t); if (void 0 === u) { const c = function iE(e) { return "function" == typeof e || "object" == typeof e && e instanceof N }(t) && lo(t); u = c && this.injectableDefInScope(c) ? Nn(Pa(t), ti) : null, this.records.set(t, u) } if (null != u) return this.hydrate(t, u) } return (r & F.Self ? ni() : this.parent).get(t, n = r & F.Optional && n === ir ? null : n) } catch (a) { if ("NullInjectorError" === a.name) { if ((a[po] = a[po] || []).unshift(ae(t)), i) throw a; return function KD(e, t, n, r) { const o = e[po]; throw t[Dl] && o.unshift(t[Dl]), e.message = function XD(e, t, n, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.slice(2) : e; let o = ae(t); if (Array.isArray(t)) o = t.map(ae).join(" -> "); else if ("object" == typeof t) { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : ae(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(qD, "\n  ")}` }("\n" + e.message, o, n, r), e.ngTokenPath = o, e[po] = null, e }(a, t, "R3InjectorError", this.source) } throw a } finally { Me(s), Rt(i) } } resolveInjectorInitializers() { const t = Rt(this), n = Me(void 0); try { const o = this.get(Jo.multi, V, F.Self); for (const i of o) i() } finally { Rt(t), Me(n) } } toString() { const t = [], n = this.records; for (const r of n.keys()) t.push(ae(r)); return `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new w(205, !1) } processProvider(t) { let n = Xt(t = b(t)) ? t : b(t && t.provide); const r = function nE(e) { return Na(e) ? Nn(void 0, e.useValue) : Nn(function Pf(e, t, n) { let r; if (Xt(e)) { const o = b(e); return Zt(o) || Pa(o) } if (Na(e)) r = () => b(e.useValue); else if (function Rf(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...Ss(e.deps || [])); else if (function xf(e) { return !(!e || !e.useExisting) }(e)) r = () => j(b(e.useExisting)); else { const o = b(e && (e.useClass || e.provide)); if (!function rE(e) { return !!e.deps }(e)) return Zt(o) || Pa(o); r = () => new o(...Ss(e.deps)) } return r }(e), ti) }(t); if (Xt(t) || !0 !== t.multi) this.records.get(n); else { let o = this.records.get(n); o || (o = Nn(void 0, ti, !0), o.factory = () => Ss(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n) { return n.value === ti && (n.value = eE, n.value = n.factory()), "object" == typeof n.value && n.value && function oE(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const n = b(t.providedIn); return "string" == typeof n ? "any" === n || this.scopes.has(n) : this.injectorDefTypes.has(n) } removeOnDestroy(t) { const n = this._onDestroyHooks.indexOf(t); -1 !== n && this._onDestroyHooks.splice(n, 1) } } function Pa(e) { const t = lo(e), n = null !== t ? t.factory : Zt(e); if (null !== n) return n; if (e instanceof N) throw new w(204, !1); if (e instanceof Function) return function tE(e) { const t = e.length; if (t > 0) throw function wr(e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n }(t, "?"), new w(204, !1); const n = function $D(e) { return e && (e[ho] || e[pl]) || null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new w(204, !1) } function Nn(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function Oa(e, t) { for (const n of e) Array.isArray(n) ? Oa(n, t) : n && Ds(n) ? Oa(n.\u0275providers, t) : t(n) } const Fa = new N("AppId", { providedIn: "root", factory: () => sE }), sE = "ng", Of = new N("Platform Initializer"), xn = new N("Platform ID", { providedIn: "platform", factory: () => "unknown" }), Ff = new N("CSP nonce", { providedIn: "root", factory: () => function Tn() { if (void 0 !== Ea) return Ea; if (typeof document < "u") return document; throw new w(210, !1) }().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null }); let Lf = (e, t, n) => null; function $a(e, t, n = !1) { return Lf(e, t, n) } class mE { } class Bf { } class DE { resolveComponentFactory(t) { throw function yE(e) { const t = Error(`No component factory found for ${ae(e)}.`); return t.ngComponent = e, t }(t) } } let Pn = (() => { class t { } return t.NULL = new DE, t })(); function vE() { return On(he(), y()) } function On(e, t) { return new Fn(Ae(e, t)) } let Fn = (() => { class t { constructor(r) { this.nativeElement = r } } return t.__NG_ELEMENT_ID__ = vE, t })(); class $f { } let EE = (() => { var e; class t { } return (e = t).\u0275prov = z({ token: e, providedIn: "root", factory: () => null }), t })(); class ci { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const CE = new ci("16.2.0"), Ga = {}; function Wf(e, t = null, n = null, r) { const o = function Zf(e, t = null, n = null, r, o = new Set) { const i = [n || V, Kw(e)]; return r = r || ("object" == typeof e ? void 0 : ae(e)), new ri(i, t || ni(), r || null, o) }(e, t, n, r); return o.resolveInjectorInitializers(), o } let Qe = (() => { var e; class t { static create(r, o) { if (Array.isArray(r)) return Wf({ name: "" }, o, r, ""); { const i = r.name ?? ""; return Wf({ name: i }, r.parent, r.providers, i) } } } return (e = t).THROW_IF_NOT_FOUND = ir, e.NULL = new Ta, e.\u0275prov = z({ token: e, providedIn: "any", factory: () => j(bf) }), e.__NG_ELEMENT_ID__ = -1, t })(), Za = (() => { var e; class t { constructor() { this.callbacks = new Set, this.deferredCallbacks = new Set, this.renderDepth = 0, this.runningCallbacks = !1 } begin() { if (this.runningCallbacks) throw new w(102, !1); this.renderDepth++ } end() { if (this.renderDepth--, 0 === this.renderDepth) try { this.runningCallbacks = !0; for (const r of this.callbacks) r.invoke() } finally { this.runningCallbacks = !1; for (const r of this.deferredCallbacks) this.callbacks.add(r); this.deferredCallbacks.clear() } } register(r) { (this.runningCallbacks ? this.deferredCallbacks : this.callbacks).add(r) } unregister(r) { this.callbacks.delete(r), this.deferredCallbacks.delete(r) } ngOnDestroy() { this.callbacks.clear(), this.deferredCallbacks.clear() } } return (e = t).\u0275prov = z({ token: e, providedIn: "root", factory: () => new e }), t })(); function Pr(e) { for (; e;) { e[A] |= 64; const t = Ir(e); if (Os(e) && !t) return e; e = t } return null } function Ya(e) { return e.ngOriginalError } class Jt { constructor() { this._console = console } handleError(t) { const n = this._findOriginalError(t); this._console.error("ERROR", t), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(t) { let n = t && Ya(t); for (; n && Ya(n);)n = Ya(n); return n || null } } const Jf = new N("", { providedIn: "root", factory: () => !1 }); class rh extends Hl { constructor() { super(...arguments), this.consumerAllowSignalWrites = !1, this._lView = null } set lView(t) { this._lView = t } onConsumerDependencyMayHaveChanged() { Pr(this._lView) } onProducerUpdateValueVersion() { } get hasReadASignal() { return this.hasProducers } runInContext(t, n, r) { const o = le(this); this.trackingVersion++; try { t(n, r) } finally { le(o) } } destroy() { this.trackingVersion++ } } let di = null; function oh() { return di ??= new rh, di } function ih(e, t) { return e[t] ?? oh() } function sh(e, t) { const n = oh(); n.hasReadASignal && (e[t] = di, n.lView = e, di = new rh) } const x = {}; function R(e, t = F.Default) { const n = y(); return null === n ? j(e, t) : Cd(he(), n, b(e), t) } function fi(e, t, n, r, o, i, s, a, u, c, l) { const d = t.blueprint.slice(); return d[ee] = o, d[A] = 140 | r, (null !== c || e && 2048 & e[A]) && (d[A] |= 2048), Xl(d), d[K] = d[ln] = e, d[te] = n, d[cn] = s || e && e[cn], d[T] = a || e && e[T], d[Pt] = u || e && e[Pt] || null, d[pe] = i, d[hr] = function X_() { return K_++ }(), d[yt] = l, d[Fl] = c, d[ne] = 2 == t.type ? e[ne] : d, d } function jn(e, t, n, r, o) { let i = e.data[t]; if (null === i) i = function Qa(e, t, n, r, o) { const i = od(), s = Bs(), u = e.data[t] = function ZE(e, t, n, r, o, i) { let s = t ? t.injectorIndex : -1, a = 0; return function pn() { return null !== I.skipHydrationRootTNode }() && (a |= 128), { type: n, index: r, insertBeforeIndex: null, injectorIndex: s, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: a, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, n, t, r, o); return null === e.firstChild && (e.firstChild = u), null !== i && (s ? null == i.child && null !== u.parent && (i.child = u) : null === i.next && (i.next = u, u.prev = i)), u }(e, t, n, r, o), function Qv() { return I.lFrame.inI18n }() && (i.flags |= 32); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = o; const s = function gr() { const e = I.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return at(i, !0), i } function Or(e, t, n, r) { if (0 === n) return -1; const o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function uh(e, t, n, r, o) { const i = ih(t, vo), s = function ve() { return I.lFrame.selectedIndex }(), a = 2 & r; try { if (Yt(-1), a && t.length > P && function ah(e, t, n, r) { if (!r) if (3 == (3 & t[A])) { const i = e.preOrderCheckHooks; null !== i && No(t, i, n) } else { const i = e.preOrderHooks; null !== i && xo(t, i, 0, n) } Yt(n) }(e, t, P, !1), st(a ? 2 : 0, o), a) i.runInContext(n, r, o); else { const c = le(null); try { n(r, o) } finally { le(c) } } } finally { a && null === t[vo] && sh(t, vo), Yt(s), st(a ? 3 : 1, o) } } function Ka(e, t, n) { if (Ps(t)) { const r = le(null); try { const i = t.directiveEnd; for (let s = t.directiveStart; s < i; s++) { const a = e.data[s]; a.contentQueries && a.contentQueries(1, n[s], s) } } finally { le(r) } } } function ch(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = eu(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts, e.id) : t } function eu(e, t, n, r, o, i, s, a, u, c, l) { const d = P + r, f = d + o, h = function $E(e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : x); return n }(d, f), p = "function" == typeof c ? c() : c; return h[_] = { type: e, blueprint: h, template: n, queries: null, viewQuery: a, declTNode: t, data: h.slice().fill(null, d), bindingStartIndex: d, expandoStartIndex: f, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: u, consts: p, incompleteFirstPass: !1, ssrId: l } } let lh = e => null; function dh(e, t, n, r) { for (let o in e) if (e.hasOwnProperty(o)) { n = null === n ? {} : n; const i = e[o]; null === r ? fh(n, t, o, i) : r.hasOwnProperty(o) && fh(n, t, r[o], i) } return n } function fh(e, t, n, r) { e.hasOwnProperty(n) ? e[n].push(t, r) : e[n] = [t, r] } function hh(e, t, n, r, o, i) { for (let c = 0; c < r.length; c++)Xs(Po(n, t), e, r[c].type); !function sC(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t }(n, e.data.length, r.length); for (let c = 0; c < r.length; c++) { const l = r[c]; l.providersResolver && l.providersResolver(l) } let s = !1, a = !1, u = Or(e, t, r.length, null); for (let c = 0; c < r.length; c++) { const l = r[c]; n.mergedAttrs = ur(n.mergedAttrs, l.hostAttrs), aC(e, n, t, u, l), iC(u, l, o), null !== l.contentQueries && (n.flags |= 4), (null !== l.hostBindings || null !== l.hostAttrs || 0 !== l.hostVars) && (n.flags |= 64); const d = l.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((e.preOrderHooks ??= []).push(n.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((e.preOrderCheckHooks ??= []).push(n.index), a = !0), u++ } !function YE(e, t, n) { const o = t.directiveEnd, i = e.data, s = t.attrs, a = []; let u = null, c = null; for (let l = t.directiveStart; l < o; l++) { const d = i[l], f = n ? n.get(d) : null, p = f ? f.outputs : null; u = dh(d.inputs, l, u, f ? f.inputs : null), c = dh(d.outputs, l, c, p); const g = null === u || null === s || Sl(t) ? null : lC(u, l, s); a.push(g) } null !== u && (u.hasOwnProperty("class") && (t.flags |= 8), u.hasOwnProperty("style") && (t.flags |= 16)), t.initialInputs = a, t.inputs = u, t.outputs = c }(e, n, i) } function ph(e, t, n) { const r = n.directiveStart, o = n.directiveEnd, i = n.index, s = function Xv() { return I.lFrame.currentDirectiveIndex }(); try { Yt(i); for (let a = r; a < o; a++) { const u = e.data[a], c = t[a]; $s(a), (null !== u.hostBindings || 0 !== u.hostVars || null !== u.hostAttrs) && nC(u, c) } } finally { Yt(-1), $s(s) } } function nC(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function nu(e, t, n) { t.componentOffset = n, (e.components ??= []).push(t.index) } function iC(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; Ye(t) && (n[""] = e) } } function aC(e, t, n, r, o) { e.data[r] = o; const i = o.factory || (o.factory = Zt(o.type)), s = new mr(i, Ye(o), R); e.blueprint[r] = s, n[r] = s, function JE(e, t, n, r, o) { const i = o.hostBindings; if (i) { let s = e.hostBindingOpCodes; null === s && (s = e.hostBindingOpCodes = []); const a = ~t.index; (function eC(e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(s) != a && s.push(a), s.push(n, r, i) } }(e, t, r, Or(e, n, o.hostVars, x), o) } function cC(e, t, n, r, o, i) { const s = i[t]; if (null !== s) for (let a = 0; a < s.length;)gh(r, n, s[a++], s[a++], s[a++]) } function gh(e, t, n, r, o) { const i = le(null); try { const s = e.inputTransforms; null !== s && s.hasOwnProperty(r) && (o = s[r].call(t, o)), null !== e.setInput ? e.setInput(t, o, n, r) : t[r] = o } finally { le(i) } } function lC(e, t, n) { let r = null, o = 0; for (; o < n.length;) { const i = n[o]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; if (e.hasOwnProperty(i)) { null === r && (r = []); const s = e[i]; for (let a = 0; a < s.length; a += 2)if (s[a] === t) { r.push(i, s[a + 1], n[o + 1]); break } } o += 2 } else o += 2; else o += 4 } return r } function yh(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r + 1]; if (-1 !== i) { const s = e.data[i]; zs(n[r]), s.contentQueries(2, t[i], i) } } } function hi(e, t) { return e[dr] ? e[Ol][Ze] = t : e[dr] = t, e[Ol] = t, t } function ou(e, t, n) { zs(0); const r = le(null); try { t(e, n) } finally { le(r) } } function iu(e, t, n, r, o) { for (let i = 0; i < n.length;) { const s = n[i++], a = n[i++]; gh(e.data[s], t[s], r, a, o) } } function dC(e, t) { const n = ke(t, e), r = n[_]; !function fC(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) }(r, n); const o = n[ee]; null !== o && null === n[yt] && (n[yt] = $a(o, n[Pt])), su(r, n, n[te]) } function su(e, t, n) { Gs(t); try { const r = e.viewQuery; null !== r && ou(1, r, n); const o = e.template; null !== o && uh(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && yh(e, t), e.staticViewQueries && ou(2, e.viewQuery, n); const i = e.components; null !== i && function hC(e, t) { for (let n = 0; n < t.length; n++)dC(e, t[n]) }(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[A] &= -5, qs() } } let Eh = (() => { var e; class t { constructor() { this.all = new Set, this.queue = new Map } create(r, o, i) { const s = typeof Zone > "u" ? null : Zone.current, a = new Sv(r, l => { this.all.has(l) && this.queue.set(l, s) }, i); let u; this.all.add(a), a.notify(); const c = () => { a.cleanup(), u?.(), this.all.delete(a), this.queue.delete(a) }; return u = o?.onDestroy(c), { destroy: c } } flush() { if (0 !== this.queue.size) for (const [r, o] of this.queue) this.queue.delete(r), o ? o.run(() => r.run()) : r.run() } get isQueueEmpty() { return 0 === this.queue.size } } return (e = t).\u0275prov = z({ token: e, providedIn: "root", factory: () => new e }), t })(); function pi(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? i = a : 1 == i ? o = gs(o, a) : 2 == i && (r = gs(r, a + ": " + t[++s] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } function Fr(e, t, n, r, o = !1) { for (; null !== n;) { const i = t[n.index]; if (null !== i && r.push(Z(i)), Te(i)) { for (let a = fe; a < i.length; a++) { const u = i[a], c = u[_].firstChild; null !== c && Fr(u[_], u, c, r) } i[ot] !== i[ee] && r.push(i[ot]) } const s = n.type; if (8 & s) Fr(e, t, n.child, r); else if (32 & s) { const a = ha(n, t); let u; for (; u = a();)r.push(u) } else if (16 & s) { const a = cf(t, n); if (Array.isArray(a)) r.push(...a); else { const u = Ir(t[ne]); Fr(u[_], u, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } function gi(e, t, n, r = !0) { const o = t[cn], i = o.rendererFactory, s = o.afterRenderEventManager; i.begin?.(), s?.begin(); try { Ch(e, t, e.template, n) } catch (u) { throw r && function wh(e, t) { const n = e[Pt], r = n ? n.get(Jt, null) : null; r && r.handleError(t) }(t, u), u } finally { i.end?.(), o.effectManager?.flush(), s?.end() } } function Ch(e, t, n, r) { const o = t[A]; if (256 != (256 & o)) { t[cn].effectManager?.flush(), Gs(t); try { Xl(t), function sd(e) { return I.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== n && uh(e, t, n, 2, r); const s = 3 == (3 & o); if (s) { const c = e.preOrderCheckHooks; null !== c && No(t, c, null) } else { const c = e.preOrderHooks; null !== c && xo(t, c, 0, null), Ws(t, 0) } if (function mC(e) { for (let t = Qd(e); null !== t; t = Kd(t)) { if (!t[kl]) continue; const n = t[fn]; for (let r = 0; r < n.length; r++) { Lv(n[r]) } } }(t), Ih(t, 2), null !== e.contentQueries && yh(e, t), s) { const c = e.contentCheckHooks; null !== c && No(t, c) } else { const c = e.contentHooks; null !== c && xo(t, c, 1), Ws(t, 1) } !function HE(e, t) { const n = e.hostBindingOpCodes; if (null === n) return; const r = ih(t, _o); try { for (let o = 0; o < n.length; o++) { const i = n[o]; if (i < 0) Yt(~i); else { const s = i, a = n[++o], u = n[++o]; Kv(a, s), r.runInContext(u, 2, t[s]) } } } finally { null === t[_o] && sh(t, _o), Yt(-1) } }(e, t); const a = e.components; null !== a && bh(t, a, 0); const u = e.viewQuery; if (null !== u && ou(2, u, r), s) { const c = e.viewCheckHooks; null !== c && No(t, c) } else { const c = e.viewHooks; null !== c && xo(t, c, 2), Ws(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), t[A] &= -73, Jl(t) } finally { qs() } } } function Ih(e, t) { for (let n = Qd(e); null !== n; n = Kd(n))for (let r = fe; r < n.length; r++)Mh(n[r], t) } function yC(e, t, n) { Mh(ke(t, e), n) } function Mh(e, t) { if (!function Fv(e) { return 128 == (128 & e[A]) }(e)) return; const n = e[_]; if (80 & e[A] && 0 === t || 1024 & e[A] || 2 === t) Ch(n, e, n.template, e[te]); else if (e[lr] > 0) { Ih(e, 1); const o = e[_].components; null !== o && bh(e, o, 1) } } function bh(e, t, n) { for (let r = 0; r < t.length; r++)yC(e, t[r], n) } class kr { get rootNodes() { const t = this._lView, n = t[_]; return Fr(n, t, n.firstChild, []) } constructor(t, n) { this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[te] } set context(t) { this._lView[te] = t } get destroyed() { return 256 == (256 & this._lView[A]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[K]; if (Te(t)) { const n = t[8], r = n ? n.indexOf(this) : -1; r > -1 && (function qo(e, t) { if (e.length <= fe) return; const n = fe + t, r = e[n]; if (r) { const o = r[fr]; null !== o && o !== e && ef(o, r), t > 0 && (e[n - 1][Ze] = r[Ze]); const i = ko(e, fe + t); !function lw(e, t) { br(e, t, t[T], 2, null, null), t[ee] = null, t[pe] = null }(r[_], r); const s = i[rt]; null !== s && s.detachView(i[_]), r[K] = null, r[Ze] = null, r[A] &= -129 } return r }(t, r), ko(n, r)) } this._attachedToViewContainer = !1 } !function ga(e, t) { if (!(256 & t[A])) { const n = t[T]; t[vo]?.destroy(), t[_o]?.destroy(), n.destroyNode && br(e, t, n, 3, null, null), function hw(e) { let t = e[dr]; if (!t) return ma(e[_], e); for (; t;) { let n = null; if (Se(t)) n = t[dr]; else { const r = t[fe]; r && (n = r) } if (!n) { for (; t && !t[Ze] && t !== e;)Se(t) && ma(t[_], t), t = t[K]; null === t && (t = e), Se(t) && ma(t[_], t), n = t && t[Ze] } t = n } }(t) } }(this._lView[_], this._lView) } onDestroy(t) { !function td(e, t) { if (256 == (256 & e[A])) throw new w(911, !1); null === e[Ot] && (e[Ot] = []), e[Ot].push(t) }(this._lView, t) } markForCheck() { Pr(this._cdRefInjectingView || this._lView) } detach() { this._lView[A] &= -129 } reattach() { this._lView[A] |= 128 } detectChanges() { gi(this._lView[_], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new w(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function fw(e, t) { br(e, t, t[T], 2, null, null) }(this._lView[_], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new w(902, !1); this._appRef = t } } class DC extends kr { constructor(t) { super(t), this._view = t } detectChanges() { const t = this._view; gi(t[_], t, t[te], !1) } checkNoChanges() { } get context() { return null } } class Sh extends Pn { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const n = k(t); return new Lr(n, this.ngModule) } } function Th(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } class _C { constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { r = go(r); const o = this.injector.get(t, Ga, r); return o !== Ga || n === Ga ? o : this.parentInjector.get(t, n, r) } } class Lr extends Bf { get inputs() { const t = this.componentDef, n = t.inputTransforms, r = Th(t.inputs); if (null !== n) for (const o of r) n.hasOwnProperty(o.propName) && (o.transform = n[o.propName]); return r } get outputs() { return Th(this.componentDef.outputs) } constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = function uv(e) { return e.map(av).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } create(t, n, r, o) { let i = (o = o || this.ngModule) instanceof wt ? o : o?.injector; i && null !== this.componentDef.getStandaloneInjector && (i = this.componentDef.getStandaloneInjector(i) || i); const s = i ? new _C(t, i) : t, a = s.get($f, null); if (null === a) throw new w(407, !1); const d = { rendererFactory: a, sanitizer: s.get(EE, null), effectManager: s.get(Eh, null), afterRenderEventManager: s.get(Za, null) }, f = a.createRenderer(null, this.componentDef), h = this.componentDef.selectors[0][0] || "div", p = r ? function UE(e, t, n, r) { const i = r.get(Jf, !1) || n === qe.ShadowDom, s = e.selectRootElement(t, i); return function zE(e) { lh(e) }(s), s }(f, r, this.componentDef.encapsulation, s) : Go(f, h, function vC(e) { const t = e.toLowerCase(); return "svg" === t ? "svg" : "math" === t ? "math" : null }(h)), v = this.componentDef.signals ? 4608 : this.componentDef.onPush ? 576 : 528; let m = null; null !== p && (m = $a(p, s, !0)); const E = eu(0, null, null, 1, 0, null, null, null, null, null, null), M = fi(null, E, null, v, null, null, d, f, s, null, m); let O, Pe; Gs(M); try { const At = this.componentDef; let tr, Rc = null; At.findHostDirectiveDefs ? (tr = [], Rc = new Map, At.findHostDirectiveDefs(At, tr, Rc), tr.push(At)) : tr = [At]; const ON = function EC(e, t) { const n = e[_], r = P; return e[r] = t, jn(n, r, 2, "#host", null) }(M, p), FN = function CC(e, t, n, r, o, i, s) { const a = o[_]; !function IC(e, t, n, r) { for (const o of e) t.mergedAttrs = ur(t.mergedAttrs, o.hostAttrs); null !== t.mergedAttrs && (pi(t, t.mergedAttrs, !0), null !== n && hf(r, n, t)) }(r, e, t, s); let u = null; null !== t && (u = $a(t, o[Pt])); const c = i.rendererFactory.createRenderer(t, n); let l = 16; n.signals ? l = 4096 : n.onPush && (l = 64); const d = fi(o, ch(n), null, l, o[e.index], e, i, c, null, null, u); return a.firstCreatePass && nu(a, e, r.length - 1), hi(o, d), o[e.index] = d }(ON, p, At, tr, M, d, f); Pe = function Kl(e, t) { return e.data[t] }(E, P), p && function bC(e, t, n, r) { if (r) Ns(e, n, ["ng-version", CE.full]); else { const { attrs: o, classes: i } = function cv(e) { const t = [], n = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && t.push(i, e[++r]) : 8 === o && n.push(i); else { if (!We(o)) break; o = i } r++ } return { attrs: t, classes: n } }(t.selectors[0]); o && Ns(e, n, o), i && i.length > 0 && ff(e, n, i.join(" ")) } }(f, At, p, r), void 0 !== n && function SC(e, t, n) { const r = e.projection = []; for (let o = 0; o < t.length; o++) { const i = n[o]; r.push(null != i ? Array.from(i) : null) } }(Pe, this.ngContentSelectors, n), O = function MC(e, t, n, r, o, i) { const s = he(), a = o[_], u = Ae(s, o); hh(a, o, s, n, null, r); for (let l = 0; l < n.length; l++)ge(Qt(o, a, s.directiveStart + l, s), o); ph(a, o, s), u && ge(u, o); const c = Qt(o, a, s.directiveStart + s.componentOffset, s); if (e[te] = o[te] = c, null !== i) for (const l of i) l(c, t); return Ka(a, s, e), c }(FN, At, tr, Rc, M, [TC]), su(E, M, null) } finally { qs() } return new wC(this.componentType, O, On(Pe, M), M, Pe) } } class wC extends mE { constructor(t, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.previousInputValues = null, this.instance = n, this.hostView = this.changeDetectorRef = new DC(o), this.componentType = t } setInput(t, n) { const r = this._tNode.inputs; let o; if (null !== r && (o = r[t])) { if (this.previousInputValues ??= new Map, this.previousInputValues.has(t) && Object.is(this.previousInputValues.get(t), n)) return; const i = this._rootLView; iu(i[_], i, o, t, n), this.previousInputValues.set(t, n), Pr(ke(this._tNode.index, i)) } } get injector() { return new _e(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } function TC() { const e = he(); Ao(y()[_], e) } function hu(e, t, n, r, o) { const s = o ? "class" : "style"; iu(e, n, t.inputs[s], s, r) } function Ei(e, t, n, r) { const o = y(), i = L(), s = P + e, a = o[T], u = i.firstCreatePass ? function lI(e, t, n, r, o, i) { const s = t.consts, u = jn(t, e, 2, r, Ft(s, o)); return function tu(e, t, n, r) { if (rd()) { const o = null === r ? null : { "": -1 }, i = function rC(e, t) { const n = e.directiveRegistry; let r = null, o = null; if (n) for (let i = 0; i < n.length; i++) { const s = n[i]; if (Tl(t, s.selectors, !1)) if (r || (r = []), Ye(s)) if (null !== s.findHostDirectiveDefs) { const a = []; o = o || new Map, s.findHostDirectiveDefs(s, a, o), r.unshift(...a, s), nu(e, t, a.length) } else r.unshift(s), nu(e, t, 0); else o = o || new Map, s.findHostDirectiveDefs?.(s, r, o), r.push(s) } return null === r ? null : [r, o] }(e, n); let s, a; null === i ? s = a = null : [s, a] = i, null !== s && hh(e, t, n, s, o, a), o && function oC(e, t, n) { if (t) { const r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { const i = n[t[o + 1]]; if (null == i) throw new w(-301, !1); r.push(t[o], i) } } }(n, r, o) } n.mergedAttrs = ur(n.mergedAttrs, n.attrs) }(t, n, u, Ft(s, i)), null !== u.attrs && pi(u, u.attrs, !1), null !== u.mergedAttrs && pi(u, u.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, u), u }(s, i, o, t, n, r) : i.data[s], c = Kh(i, o, u, a, t, e); o[s] = c; const l = function Eo(e) { return 1 == (1 & e.flags) }(u); return at(u, !0), hf(a, c, u), 32 != (32 & u.flags) && To() && Zo(i, o, c, u), 0 === function Vv() { return I.lFrame.elementDepthCount }() && ge(c, o), function Bv() { I.lFrame.elementDepthCount++ }(), l && (function Xa(e, t, n) { rd() && (function tC(e, t, n, r) { const o = n.directiveStart, i = n.directiveEnd; Wt(n) && function uC(e, t, n) { const r = Ae(t, e), o = ch(n); let s = 16; n.signals ? s = 4096 : n.onPush && (s = 64); const a = hi(e, fi(e, o, null, s, r, t, null, e[cn].rendererFactory.createRenderer(r, n), null, null, null)); e[t.index] = a }(t, n, e.data[o + n.componentOffset]), e.firstCreatePass || Po(n, t), ge(r, t); const s = n.initialInputs; for (let a = o; a < i; a++) { const u = e.data[a], c = Qt(t, e, a, n); ge(c, t), null !== s && cC(0, a - o, c, u, 0, s), Ye(u) && (ke(n.index, t)[te] = Qt(t, e, a, n)) } }(e, t, n, Ae(n, t)), 64 == (64 & n.flags) && ph(e, t, n)) }(i, o, u), Ka(i, u, o)), null !== r && function Ja(e, t, n = Ae) { const r = t.localNames; if (null !== r) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? n(t, e) : e[s]; e[o++] = a } } }(o, u), Ei } function Ci() { let e = he(); Bs() ? function Hs() { I.lFrame.isParent = !1 }() : (e = e.parent, at(e, !1)); const t = e; (function $v(e) { return I.skipHydrationRootTNode === e })(t) && function qv() { I.skipHydrationRootTNode = null }(), function Hv() { I.lFrame.elementDepthCount-- }(); const n = L(); return n.firstCreatePass && (Ao(n, e), Ps(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function c_(e) { return 0 != (8 & e.flags) }(t) && hu(n, t, y(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function l_(e) { return 0 != (16 & e.flags) }(t) && hu(n, t, y(), t.stylesWithoutHost, !1), Ci } let Kh = (e, t, n, r, o, i) => (kt(!0), Go(r, o, function pd() { return I.lFrame.currentNamespace }())); function mu(e) { return !!e && "function" == typeof e.then } function ep(e) { return !!e && "function" == typeof e.subscribe } let xp = (e, t, n, r, o) => (kt(!0), function zo(e, t) { return e.createText(t) }(t[T], r)); const Qn = "en-US"; let eg = Qn; class rn { } class bg extends rn { constructor(t) { super(), this.componentFactoryResolver = new Sh(this), this.instance = null; const n = new ri([...t.providers, { provide: rn, useValue: this }, { provide: Pn, useValue: this.componentFactoryResolver }], t.parent || ni(), t.debugName, new Set(["environment"])); this.injector = n, t.runEnvironmentInitializers && n.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(t) { this.injector.onDestroy(t) } } let mb = (() => { var e; class t { constructor(r) { this._injector = r, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(r) { if (!r.standalone) return null; if (!this.cachedInjectors.has(r)) { const o = Af(0, r.type), i = o.length > 0 ? function gb(e, t, n = null) { return new bg({ providers: e, parent: t, debugName: n, runEnvironmentInitializers: !0 }).injector }([o], this._injector, `Standalone[${r.type.name}]`) : null; this.cachedInjectors.set(r, i) } return this.cachedInjectors.get(r) } ngOnDestroy() { try { for (const r of this.cachedInjectors.values()) null !== r && r.destroy() } finally { this.cachedInjectors.clear() } } } return (e = t).\u0275prov = z({ token: e, providedIn: "environment", factory: () => new e(j(wt)) }), t })(); function Sg(e) { e.getStandaloneInjector = t => t.get(mb).getOrCreateStandaloneInjector(e) } function Ru(e) { return t => { setTimeout(e, void 0, t) } } const It = class $b extends or { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && "object" == typeof t) { const u = t; o = u.next?.bind(u), i = u.error?.bind(u), s = u.complete?.bind(u) } this.__isAsync && (i = Ru(i), o && (o = Ru(o)), s && (s = Ru(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof tt && t.add(a), a } }, L0 = new N("Application Initializer"); let zu = (() => { var e; class t { constructor() { this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, o) => { this.resolve = r, this.reject = o }), this.appInits = W(L0, { optional: !0 }) ?? [] } runInitializers() { if (this.initialized) return; const r = []; for (const i of this.appInits) { const s = i(); if (mu(s)) r.push(s); else if (ep(s)) { const a = new Promise((u, c) => { s.subscribe({ complete: u, error: c }) }); r.push(a) } } const o = () => { this.done = !0, this.resolve() }; Promise.all(r).then(() => { o() }).catch(i => { this.reject(i) }), 0 === r.length && o(), this.initialized = !0 } } return (e = t).\u0275fac = function (r) { return new (r || e) }, e.\u0275prov = z({ token: e, factory: e.\u0275fac, providedIn: "root" }), t })(); const bt = new N("LocaleId", { providedIn: "root", factory: () => W(bt, F.Optional | F.SkipSelf) || function V0() { return typeof $localize < "u" && $localize.locale || Qn }() }); let $0 = (() => { var e; class t { constructor() { this.taskId = 0, this.pendingTasks = new Set, this.hasPendingTasks = new Gy(!1) } add() { this.hasPendingTasks.next(!0); const r = this.taskId++; return this.pendingTasks.add(r), r } remove(r) { this.pendingTasks.delete(r), 0 === this.pendingTasks.size && this.hasPendingTasks.next(!1) } ngOnDestroy() { this.pendingTasks.clear(), this.hasPendingTasks.next(!1) } } return (e = t).\u0275fac = function (r) { return new (r || e) }, e.\u0275prov = z({ token: e, factory: e.\u0275fac, providedIn: "root" }), t })(); function vm(...e) { } class ie { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new It(!1), this.onMicrotaskEmpty = new It(!1), this.onStable = new It(!1), this.onError = new It(!1), typeof Zone > "u") throw new w(908, !1); Zone.assertZonePatched(); const o = this; o._nesting = 0, o._outer = o._inner = Zone.current, Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && n, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function cS() { const e = "function" == typeof G.requestAnimationFrame; let t = G[e ? "requestAnimationFrame" : "setTimeout"], n = G[e ? "cancelAnimationFrame" : "clearTimeout"]; if (typeof Zone < "u" && t && n) { const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r); const o = n[Zone.__symbol__("OriginalDelegate")]; o && (n = o) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: n } }().nativeRequestAnimationFrame, function fS(e) { const t = () => { !function dS(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(G, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, Zu(e), e.isCheckStableRunning = !0, Wu(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), Zu(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, o, i, s, a) => { try { return _m(e), n.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && t(), wm(e) } }, onInvoke: (n, r, o, i, s, a, u) => { try { return _m(e), n.invoke(o, i, s, a, u) } finally { e.shouldCoalesceRunChangeDetection && t(), wm(e) } }, onHasTask: (n, r, o, i) => { n.hasTask(o, i), r === o && ("microTask" == i.change ? (e._hasPendingMicrotasks = i.microTask, Zu(e), Wu(e)) : "macroTask" == i.change && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (n, r, o, i) => (n.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) }(o) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!ie.isInAngularZone()) throw new w(909, !1) } static assertNotInAngularZone() { if (ie.isInAngularZone()) throw new w(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, lS, vm, vm); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } } const lS = {}; function Wu(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function Zu(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function _m(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function wm(e) { e._nesting--, Wu(e) } const Em = new N("", { providedIn: "root", factory: Cm }); function Cm() { const e = W(ie); let t = !0; return cl(new Ie(o => { t = e.isStable && !e.hasPendingMacrotasks && !e.hasPendingMicrotasks, e.runOutsideAngular(() => { o.next(t), o.complete() }) }), new Ie(o => { let i; e.runOutsideAngular(() => { i = e.onStable.subscribe(() => { ie.assertNotInAngularZone(), queueMicrotask(() => { !t && !e.hasPendingMacrotasks && !e.hasPendingMicrotasks && (t = !0, o.next(!0)) }) }) }); const s = e.onUnstable.subscribe(() => { ie.assertInAngularZone(), t && (t = !1, e.runOutsideAngular(() => { o.next(!1) })) }); return () => { i.unsubscribe(), s.unsubscribe() } }).pipe(ll())) } const Im = new N(""); let Bt = null; const Xu = new N("PlatformDestroyListeners"), bm = new N("appBootstrapListener"); function vS(e) { try { const { rootComponent: t, appProviders: n, platformProviders: r } = e, o = function DS(e = []) { if (Bt) return Bt; const t = function Am(e = [], t) { return Qe.create({ name: t, providers: [{ provide: xa, useValue: "platform" }, { provide: Xu, useValue: new Set([() => Bt = null]) }, ...e] }) }(e); return Bt = t, function Sm() { !function Mv(e) { $l = e }(() => { throw new w(600, !1) }) }(), function Tm(e) { e.get(Of, null)?.forEach(n => n()) }(t), t }(r), i = [IS(), ...n || []], a = new bg({ providers: i, parent: o, debugName: "", runEnvironmentInitializers: !1 }).injector, u = a.get(ie); return u.run(() => { a.resolveInjectorInitializers(); const c = a.get(Jt, null); let l; u.runOutsideAngular(() => { l = u.onError.subscribe({ next: h => { c.handleError(h) } }) }); const d = () => a.destroy(), f = o.get(Xu); return f.add(d), a.onDestroy(() => { l.unsubscribe(), f.delete(d) }), function Rm(e, t, n) { try { const r = n(); return mu(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(c, u, () => { const h = a.get(zu); return h.runInitializers(), h.donePromise.then(() => { !function tg(e) { Be(e, "Expected localeId to be defined"), "string" == typeof e && (eg = e.toLowerCase().replace(/_/g, "-")) }(a.get(bt, Qn) || Qn); const g = a.get(Jn); return void 0 !== t && g.bootstrap(t), g }) }) }) } catch (t) { return Promise.reject(t) } } let Jn = (() => { var e; class t { constructor() { this._bootstrapListeners = [], this._runningTick = !1, this._destroyed = !1, this._destroyListeners = [], this._views = [], this.internalErrorHandler = W(Fm), this.zoneIsStable = W(Em), this.componentTypes = [], this.components = [], this.isStable = W($0).hasPendingTasks.pipe(dl(r => r ? function PD(...e) { return ul(e, ol(e)) }(!1) : this.zoneIsStable), function OD(e, t = us) { return e = e ?? FD, zt((n, r) => { let o, i = !0; n.subscribe(Gt(r, s => { const a = t(s); (i || !e(o, a)) && (i = !1, o = a, r.next(s)) })) }) }(), ll()), this._injector = W(wt) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(r, o) { const i = r instanceof Bf; if (!this._injector.get(zu).done) throw !i && function cr(e) { const t = k(e) || de(e) || ye(e); return null !== t && t.standalone }(r), new w(405, !1); let a; a = i ? r : this._injector.get(Pn).resolveComponentFactory(r), this.componentTypes.push(a.componentType); const u = function mS(e) { return e.isBoundToModule }(a) ? void 0 : this._injector.get(rn), l = a.create(Qe.NULL, [], o || a.selector, u), d = l.location.nativeElement, f = l.injector.get(Im, null); return f?.registerApplication(d), l.onDestroy(() => { this.detachView(l.hostView), Fi(this.components, l), f?.unregisterApplication(d) }), this._loadComponent(l), l } tick() { if (this._runningTick) throw new w(101, !1); try { this._runningTick = !0; for (let r of this._views) r.detectChanges() } catch (r) { this.internalErrorHandler(r) } finally { this._runningTick = !1 } } attachView(r) { const o = r; this._views.push(o), o.attachToAppRef(this) } detachView(r) { const o = r; Fi(this._views, o), o.detachFromAppRef() } _loadComponent(r) { this.attachView(r.hostView), this.tick(), this.components.push(r); const o = this._injector.get(bm, []); o.push(...this._bootstrapListeners), o.forEach(i => i(r)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(r => r()), this._views.slice().forEach(r => r.destroy()) } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(r) { return this._destroyListeners.push(r), () => Fi(this._destroyListeners, r) } destroy() { if (this._destroyed) throw new w(406, !1); const r = this._injector; r.destroy && !r.destroyed && r.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return (e = t).\u0275fac = function (r) { return new (r || e) }, e.\u0275prov = z({ token: e, factory: e.\u0275fac, providedIn: "root" }), t })(); function Fi(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } const Fm = new N("", { providedIn: "root", factory: () => W(Jt).handleError.bind(void 0) }); function ES() { const e = W(ie), t = W(Jt); return n => e.runOutsideAngular(() => t.handleError(n)) } let CS = (() => { var e; class t { constructor() { this.zone = W(ie), this.applicationRef = W(Jn) } initialize() { this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => { this.zone.run(() => { this.applicationRef.tick() }) } })) } ngOnDestroy() { this._onMicrotaskEmptySubscription?.unsubscribe() } } return (e = t).\u0275fac = function (r) { return new (r || e) }, e.\u0275prov = z({ token: e, factory: e.\u0275fac, providedIn: "root" }), t })(); function km(e) { return [{ provide: ie, useFactory: e }, { provide: Jo, multi: !0, useFactory: () => { const t = W(CS, { optional: !0 }); return () => t.initialize() } }, { provide: Fm, useFactory: ES }, { provide: Em, useFactory: Cm }] } function IS(e) { return function Tf(e) { return { \u0275providers: e } }([[], km(() => new ie(function xm(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: e?.eventCoalescing ?? !1, shouldCoalesceRunChangeDetection: e?.runCoalescing ?? !1 } }(e)))]) } let jm = (() => { class t { } return t.__NG_ELEMENT_ID__ = MS, t })(); function MS(e) { return function bS(e, t, n) { if (Wt(e) && !n) { const r = ke(e.index, t); return new kr(r, r) } return 47 & e.type ? new kr(t[ne], t) : null }(he(), y(), 16 == (16 & e)) } let ic = null; function sc() { return ic } class KS { } const sn = new N("DocumentToken"); let pA = (() => { var e; class t { } return (e = t).\u0275fac = function (r) { return new (r || e) }, e.\u0275mod = xs({ type: e }), e.\u0275inj = co({}), t })(); function gy(e) { return "server" === e } class $A extends KS { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class Cc extends $A { static makeCurrent() { !function QS(e) { ic || (ic = e) }(new Cc) } onAndCancel(t, n, r) { return t.addEventListener(n, r), () => { t.removeEventListener(n, r) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return (n = n || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return "window" === n ? window : "document" === n ? t : "body" === n ? t.body : null } getBaseHref(t) { const n = function UA() { return no = no || document.querySelector("base"), no ? no.getAttribute("href") : null }(); return null == n ? null : function zA(e) { Xi = Xi || document.createElement("a"), Xi.setAttribute("href", e); const t = Xi.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(n) } resetBaseElement() { no = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return function LT(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const r = n.indexOf("="), [o, i] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null }(document.cookie, t) } } let Xi, no = null, qA = (() => { var e; class t { build() { return new XMLHttpRequest } } return (e = t).\u0275fac = function (r) { return new (r || e) }, e.\u0275prov = z({ token: e, factory: e.\u0275fac }), t })(); const Ic = new N("EventManagerPlugins"); let _y = (() => { var e; class t { constructor(r, o) { this._zone = o, this._eventNameToPlugin = new Map, r.forEach(i => { i.manager = this }), this._plugins = r.slice().reverse() } addEventListener(r, o, i) { return this._findPluginFor(o).addEventListener(r, o, i) } getZone() { return this._zone } _findPluginFor(r) { let o = this._eventNameToPlugin.get(r); if (o) return o; if (o = this._plugins.find(s => s.supports(r)), !o) throw new w(5101, !1); return this._eventNameToPlugin.set(r, o), o } } return (e = t).\u0275fac = function (r) { return new (r || e)(j(Ic), j(ie)) }, e.\u0275prov = z({ token: e, factory: e.\u0275fac }), t })(); class wy { constructor(t) { this._doc = t } } const Mc = "ng-app-id"; let Ey = (() => { var e; class t { constructor(r, o, i, s = {}) { this.doc = r, this.appId = o, this.nonce = i, this.platformId = s, this.styleRef = new Map, this.hostNodes = new Set, this.styleNodesInDOM = this.collectServerRenderedStyles(), this.platformIsServer = gy(s), this.resetHostNodes() } addStyles(r) { for (const o of r) 1 === this.changeUsageCount(o, 1) && this.onStyleAdded(o) } removeStyles(r) { for (const o of r) this.changeUsageCount(o, -1) <= 0 && this.onStyleRemoved(o) } ngOnDestroy() { const r = this.styleNodesInDOM; r && (r.forEach(o => o.remove()), r.clear()); for (const o of this.getAllStyles()) this.onStyleRemoved(o); this.resetHostNodes() } addHost(r) { this.hostNodes.add(r); for (const o of this.getAllStyles()) this.addStyleToHost(r, o) } removeHost(r) { this.hostNodes.delete(r) } getAllStyles() { return this.styleRef.keys() } onStyleAdded(r) { for (const o of this.hostNodes) this.addStyleToHost(o, r) } onStyleRemoved(r) { const o = this.styleRef; o.get(r)?.elements?.forEach(i => i.remove()), o.delete(r) } collectServerRenderedStyles() { const r = this.doc.head?.querySelectorAll(`style[${Mc}="${this.appId}"]`); if (r?.length) { const o = new Map; return r.forEach(i => { null != i.textContent && o.set(i.textContent, i) }), o } return null } changeUsageCount(r, o) { const i = this.styleRef; if (i.has(r)) { const s = i.get(r); return s.usage += o, s.usage } return i.set(r, { usage: o, elements: [] }), o } getStyleElement(r, o) { const i = this.styleNodesInDOM, s = i?.get(o); if (s?.parentNode === r) return i.delete(o), s.removeAttribute(Mc), s; { const a = this.doc.createElement("style"); return this.nonce && a.setAttribute("nonce", this.nonce), a.textContent = o, this.platformIsServer && a.setAttribute(Mc, this.appId), a } } addStyleToHost(r, o) { const i = this.getStyleElement(r, o); r.appendChild(i); const s = this.styleRef, a = s.get(o)?.elements; a ? a.push(i) : s.set(o, { elements: [i], usage: 1 }) } resetHostNodes() { const r = this.hostNodes; r.clear(), r.add(this.doc.head) } } return (e = t).\u0275fac = function (r) { return new (r || e)(j(sn), j(Fa), j(Ff, 8), j(xn)) }, e.\u0275prov = z({ token: e, factory: e.\u0275fac }), t })(); const bc = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Sc = /%COMP%/g, QA = new N("RemoveStylesOnCompDestroy", { providedIn: "root", factory: () => !1 }); function Iy(e, t) { return t.map(n => n.replace(Sc, e)) } let My = (() => { var e; class t { constructor(r, o, i, s, a, u, c, l = null) { this.eventManager = r, this.sharedStylesHost = o, this.appId = i, this.removeStylesOnCompDestroy = s, this.doc = a, this.platformId = u, this.ngZone = c, this.nonce = l, this.rendererByCompId = new Map, this.platformIsServer = gy(u), this.defaultRenderer = new Tc(r, a, c, this.platformIsServer) } createRenderer(r, o) { if (!r || !o) return this.defaultRenderer; this.platformIsServer && o.encapsulation === qe.ShadowDom && (o = { ...o, encapsulation: qe.Emulated }); const i = this.getOrCreateRenderer(r, o); return i instanceof Sy ? i.applyToHost(r) : i instanceof Ac && i.applyStyles(), i } getOrCreateRenderer(r, o) { const i = this.rendererByCompId; let s = i.get(o.id); if (!s) { const a = this.doc, u = this.ngZone, c = this.eventManager, l = this.sharedStylesHost, d = this.removeStylesOnCompDestroy, f = this.platformIsServer; switch (o.encapsulation) { case qe.Emulated: s = new Sy(c, l, o, this.appId, d, a, u, f); break; case qe.ShadowDom: return new eN(c, l, r, o, a, u, this.nonce, f); default: s = new Ac(c, l, o, d, a, u, f) }i.set(o.id, s) } return s } ngOnDestroy() { this.rendererByCompId.clear() } } return (e = t).\u0275fac = function (r) { return new (r || e)(j(_y), j(Ey), j(Fa), j(QA), j(sn), j(xn), j(ie), j(Ff)) }, e.\u0275prov = z({ token: e, factory: e.\u0275fac }), t })(); class Tc { constructor(t, n, r, o) { this.eventManager = t, this.doc = n, this.ngZone = r, this.platformIsServer = o, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, n) { return n ? this.doc.createElementNS(bc[n] || n, t) : this.doc.createElement(t) } createComment(t) { return this.doc.createComment(t) } createText(t) { return this.doc.createTextNode(t) } appendChild(t, n) { (by(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && (by(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = "string" == typeof t ? this.doc.querySelector(t) : t; if (!r) throw new w(-5104, !1); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; const i = bc[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { const o = bc[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (Lt.DashCase | Lt.Important) ? t.style.setProperty(n, r, o & Lt.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & Lt.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t[n] = r } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { if ("string" == typeof t && !(t = sc().getGlobalEventTarget(this.doc, t))) throw new Error(`Unsupported event target ${t} for event ${n}`); return this.eventManager.addEventListener(t, n, this.decoratePreventDefault(r)) } decoratePreventDefault(t) { return n => { if ("__ngUnwrap__" === n) return t; !1 === (this.platformIsServer ? this.ngZone.runGuarded(() => t(n)) : t(n)) && n.preventDefault() } } } function by(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class eN extends Tc { constructor(t, n, r, o, i, s, a, u) { super(t, i, s, u), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const c = Iy(o.id, o.styles); for (const l of c) { const d = document.createElement("style"); a && d.setAttribute("nonce", a), d.textContent = l, this.shadowRoot.appendChild(d) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class Ac extends Tc { constructor(t, n, r, o, i, s, a, u) { super(t, i, s, a), this.sharedStylesHost = n, this.removeStylesOnCompDestroy = o, this.styles = u ? Iy(u, r.styles) : r.styles } applyStyles() { this.sharedStylesHost.addStyles(this.styles) } destroy() { this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles) } } class Sy extends Ac { constructor(t, n, r, o, i, s, a, u) { const c = o + "-" + r.id; super(t, n, r, i, s, a, u, c), this.contentAttr = function KA(e) { return "_ngcontent-%COMP%".replace(Sc, e) }(c), this.hostAttr = function XA(e) { return "_nghost-%COMP%".replace(Sc, e) }(c) } applyToHost(t) { this.applyStyles(), this.setAttribute(t, this.hostAttr, "") } createElement(t, n) { const r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } } const Ty = ["alt", "control", "meta", "shift"], nN = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, rN = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; const cN = [{ provide: xn, useValue: "browser" }, { provide: Of, useValue: function sN() { Cc.makeCurrent() }, multi: !0 }, { provide: sn, useFactory: function uN() { return function Sw(e) { Ea = e }(document), document }, deps: [] }], dN = [{ provide: xa, useValue: "root" }, { provide: Jt, useFactory: function aN() { return new Jt }, deps: [] }, { provide: Ic, useClass: (() => { var e; class t extends wy { constructor(r) { super(r) } supports(r) { return !0 } addEventListener(r, o, i) { return r.addEventListener(o, i, !1), () => this.removeEventListener(r, o, i) } removeEventListener(r, o, i) { return r.removeEventListener(o, i) } } return (e = t).\u0275fac = function (r) { return new (r || e)(j(sn)) }, e.\u0275prov = z({ token: e, factory: e.\u0275fac }), t })(), multi: !0, deps: [sn, ie, xn] }, { provide: Ic, useClass: (() => { var e; class t extends wy { constructor(r) { super(r) } supports(r) { return null != t.parseEventName(r) } addEventListener(r, o, i) { const s = t.parseEventName(o), a = t.eventCallback(s.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => sc().onAndCancel(r, s.domEventName, a)) } static parseEventName(r) { const o = r.toLowerCase().split("."), i = o.shift(); if (0 === o.length || "keydown" !== i && "keyup" !== i) return null; const s = t._normalizeKey(o.pop()); let a = "", u = o.indexOf("code"); if (u > -1 && (o.splice(u, 1), a = "code."), Ty.forEach(l => { const d = o.indexOf(l); d > -1 && (o.splice(d, 1), a += l + ".") }), a += s, 0 != o.length || 0 === s.length) return null; const c = {}; return c.domEventName = i, c.fullKey = a, c } static matchEventFullKeyCode(r, o) { let i = nN[r.key] || r.key, s = ""; return o.indexOf("code.") > -1 && (i = r.code, s = "code."), !(null == i || !i) && (i = i.toLowerCase(), " " === i ? i = "space" : "." === i && (i = "dot"), Ty.forEach(a => { a !== i && (0, rN[a])(r) && (s += a + ".") }), s += i, s === o) } static eventCallback(r, o, i) { return s => { t.matchEventFullKeyCode(s, r) && i.runGuarded(() => o(s)) } } static _normalizeKey(r) { return "esc" === r ? "escape" : r } } return (e = t).\u0275fac = function (r) { return new (r || e)(j(sn)) }, e.\u0275prov = z({ token: e, factory: e.\u0275fac }), t })(), multi: !0, deps: [sn] }, My, Ey, _y, { provide: $f, useExisting: My }, { provide: class vA { }, useClass: qA, deps: [] }, []]; typeof window < "u" && window; const Py = { now: () => (Py.delegate || Date).now(), delegate: void 0 }; class DN extends or { constructor(t = 1 / 0, n = 1 / 0, r = Py) { super(), this._bufferSize = t, this._windowTime = n, this._timestampProvider = r, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = n === 1 / 0, this._bufferSize = Math.max(1, t), this._windowTime = Math.max(1, n) } next(t) { const { isStopped: n, _buffer: r, _infiniteTimeWindow: o, _timestampProvider: i, _windowTime: s } = this; n || (r.push(t), !o && r.push(i.now() + s)), this._trimBuffer(), super.next(t) } _subscribe(t) { this._throwIfClosed(), this._trimBuffer(); const n = this._innerSubscribe(t), { _infiniteTimeWindow: r, _buffer: o } = this, i = o.slice(); for (let s = 0; s < i.length && !t.closed; s += r ? 1 : 2)t.next(i[s]); return this._checkFinalizedStatuses(t), n } _trimBuffer() { const { _bufferSize: t, _timestampProvider: n, _buffer: r, _infiniteTimeWindow: o } = this, i = (o ? 1 : 2) * t; if (t < 1 / 0 && i < r.length && r.splice(0, r.length - i), !o) { const s = n.now(); let a = 0; for (let u = 1; u < r.length && r[u] <= s; u += 2)a = u; a && r.splice(0, a + 1) } } } const Ji = { schedule(e, t) { const n = setTimeout(e, t); return () => clearTimeout(n) }, scheduleBeforeRender(e) { if (typeof window > "u") return Ji.schedule(e, 0); if (typeof window.requestAnimationFrame > "u") return Ji.schedule(e, 16); const t = window.requestAnimationFrame(e); return () => window.cancelAnimationFrame(t) } }; let xc; function SN(e, t, n) { let r = n; return function _N(e) { return !!e && e.nodeType === Node.ELEMENT_NODE }(e) && t.some((o, i) => !("*" === o || !function EN(e, t) { if (!xc) { const n = Element.prototype; xc = n.matches || n.matchesSelector || n.mozMatchesSelector || n.msMatchesSelector || n.oMatchesSelector || n.webkitMatchesSelector } return e.nodeType === Node.ELEMENT_NODE && xc.call(e, t) }(e, o) || (r = i, 0))), r } class AN { constructor(t, n) { this.componentFactory = n.get(Pn).resolveComponentFactory(t) } create(t) { return new NN(this.componentFactory, t) } } class NN { constructor(t, n) { this.componentFactory = t, this.injector = n, this.eventEmitters = new DN(1), this.events = this.eventEmitters.pipe(dl(r => cl(...r))), this.componentRef = null, this.viewChangeDetectorRef = null, this.inputChanges = null, this.hasInputChanges = !1, this.implementsOnChanges = !1, this.scheduledChangeDetectionFn = null, this.scheduledDestroyFn = null, this.initialInputValues = new Map, this.unchangedInputs = new Set(this.componentFactory.inputs.map(({ propName: r }) => r)), this.ngZone = this.injector.get(ie), this.elementZone = typeof Zone > "u" ? null : this.ngZone.run(() => Zone.current) } connect(t) { this.runInZone(() => { if (null !== this.scheduledDestroyFn) return this.scheduledDestroyFn(), void (this.scheduledDestroyFn = null); null === this.componentRef && this.initializeComponent(t) }) } disconnect() { this.runInZone(() => { null === this.componentRef || null !== this.scheduledDestroyFn || (this.scheduledDestroyFn = Ji.schedule(() => { null !== this.componentRef && (this.componentRef.destroy(), this.componentRef = null, this.viewChangeDetectorRef = null) }, 10)) }) } getInputValue(t) { return this.runInZone(() => null === this.componentRef ? this.initialInputValues.get(t) : this.componentRef.instance[t]) } setInputValue(t, n, r) { this.runInZone(() => { r && (n = r.call(this.componentRef?.instance, n)), null !== this.componentRef ? function CN(e, t) { return e === t || e != e && t != t }(n, this.getInputValue(t)) && (void 0 !== n || !this.unchangedInputs.has(t)) || (this.recordInputChange(t, n), this.unchangedInputs.delete(t), this.hasInputChanges = !0, this.componentRef.instance[t] = n, this.scheduleDetectChanges()) : this.initialInputValues.set(t, n) }) } initializeComponent(t) { const n = Qe.create({ providers: [], parent: this.injector }), r = function bN(e, t) { const n = e.childNodes, r = t.map(() => []); let o = -1; t.some((i, s) => "*" === i && (o = s, !0)); for (let i = 0, s = n.length; i < s; ++i) { const a = n[i], u = SN(a, t, o); -1 !== u && r[u].push(a) } return r }(t, this.componentFactory.ngContentSelectors); this.componentRef = this.componentFactory.create(n, r, t), this.viewChangeDetectorRef = this.componentRef.injector.get(jm), this.implementsOnChanges = function wN(e) { return "function" == typeof e }(this.componentRef.instance.ngOnChanges), this.initializeInputs(), this.initializeOutputs(this.componentRef), this.detectChanges(), this.injector.get(Jn).attachView(this.componentRef.hostView) } initializeInputs() { this.componentFactory.inputs.forEach(({ propName: t, transform: n }) => { this.initialInputValues.has(t) && this.setInputValue(t, this.initialInputValues.get(t), n) }), this.initialInputValues.clear() } initializeOutputs(t) { const n = this.componentFactory.outputs.map(({ propName: r, templateName: o }) => t.instance[r].pipe(Hc(s => ({ name: o, value: s })))); this.eventEmitters.next(n) } callNgOnChanges(t) { if (!this.implementsOnChanges || null === this.inputChanges) return; const n = this.inputChanges; this.inputChanges = null, t.instance.ngOnChanges(n) } markViewForCheck(t) { this.hasInputChanges && (this.hasInputChanges = !1, t.markForCheck()) } scheduleDetectChanges() { this.scheduledChangeDetectionFn || (this.scheduledChangeDetectionFn = Ji.scheduleBeforeRender(() => { this.scheduledChangeDetectionFn = null, this.detectChanges() })) } recordInputChange(t, n) { if (!this.implementsOnChanges) return; null === this.inputChanges && (this.inputChanges = {}); const r = this.inputChanges[t]; if (r) return void (r.currentValue = n); const o = this.unchangedInputs.has(t), i = o ? void 0 : this.getInputValue(t); this.inputChanges[t] = new Gl(i, n, o) } detectChanges() { null !== this.componentRef && (this.callNgOnChanges(this.componentRef), this.markViewForCheck(this.viewChangeDetectorRef), this.componentRef.changeDetectorRef.detectChanges()) } runInZone(t) { return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(t) : t() } } class xN extends HTMLElement { constructor() { super(...arguments), this.ngElementEventsSubscription = null } } let PN = (() => { var e; class t { } return (e = t).\u0275fac = function (r) { return new (r || e) }, e.\u0275cmp = Nl({ type: e, selectors: [["app-tester"]], standalone: !0, features: [Sg], decls: 2, vars: 0, template: function (r, o) { 1 & r && (Ei(0, "p"), function Np(e, t = "") { const n = y(), r = L(), o = e + P, i = r.firstCreatePass ? jn(r, o, 1, t, null) : r.data[o], s = xp(r, n, i, t, e); n[o] = s, To() && Zo(r, n, s, i), at(i, !1) }(1, "tester works!"), Ci()) }, dependencies: [pA] }), t })(); !function es(e) { return function () { var t = this, n = arguments; return new Promise(function (r, o) { var i = e.apply(t, n); function s(u) { nr(i, r, o, s, a, "next", u) } function a(u) { nr(i, r, o, s, a, "throw", u) } s(void 0) }) } }(function* () { const e = yield function iN(e) { return vS(function Ay(e) { return { appProviders: [...dN, ...e?.providers ?? []], platformProviders: cN } }(e)) }({ providers: [] }), t = function RN(e, t) { const r = function MN(e, t) { return t.get(Pn).resolveComponentFactory(e).inputs }(e, t.injector), o = t.strategyFactory || new AN(e, t.injector), i = function IN(e) { const t = {}; return e.forEach(({ propName: n, templateName: r, transform: o }) => { t[function vN(e) { return e.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`) }(r)] = [n, o] }), t }(r); class s extends xN { get ngElementStrategy() { if (!this._ngElementStrategy) { const u = this._ngElementStrategy = o.create(this.injector || t.injector); r.forEach(({ propName: c, transform: l }) => { if (!this.hasOwnProperty(c)) return; const d = this[c]; delete this[c], u.setInputValue(c, d, l) }) } return this._ngElementStrategy } constructor(u) { super(), this.injector = u } attributeChangedCallback(u, c, l, d) { const [f, h] = i[u]; this.ngElementStrategy.setInputValue(f, l, h) } connectedCallback() { let u = !1; this.ngElementStrategy.events && (this.subscribeToEvents(), u = !0), this.ngElementStrategy.connect(this), u || this.subscribeToEvents() } disconnectedCallback() { this._ngElementStrategy && this._ngElementStrategy.disconnect(), this.ngElementEventsSubscription && (this.ngElementEventsSubscription.unsubscribe(), this.ngElementEventsSubscription = null) } subscribeToEvents() { this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(u => { const c = new CustomEvent(u.name, { detail: u.value }); this.dispatchEvent(c) }) } } return s.observedAttributes = Object.keys(i), r.forEach(({ propName: a, transform: u }) => { Object.defineProperty(s.prototype, a, { get() { return this.ngElementStrategy.getInputValue(a) }, set(c) { this.ngElementStrategy.setInputValue(a, c, u) }, configurable: !0, enumerable: !0 }) }), s }(PN, { injector: e.injector }); customElements.define("test-component", t) })() } }, nr => { nr(nr.s = 794) }]);